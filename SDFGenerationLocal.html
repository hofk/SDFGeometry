<!DOCTYPE html>
<!-- 
******** License details ******************

 Copyright Klaus Hoffmeister
 2025 https://hofk.de/
 
 I am the copyright holder of this software.
 You may not physically or digitally host, display, distribute, or share this software (or any modified form thereof).
 You may not use this software in commercial or non-commercial products, websites, or projects.
 You may not sell this software, and you may not create NFTs from it.
 The software may be used for the private or non-commercial generation of SDF geometries.
 The software and the generated geometries may be used for educational purposes
 and you may link to the software via a URL or source reference as part of your educational material.
 
**************************
-->
<head>
  <meta charset="utf-8">
  <title>SDFGeometry Local</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    /* container divided into two parts */
    #main-container {
      display: flex;
      height: 100%;
      width: 100%;
    }
    #left-side {
      flex: 0.8;
      position: relative;
      background-color: #cccccc;
    }
    #right-side {
      flex: 0.2;
      background-color: #f9f9f9;
      display: flex;
      flex-direction: column;
      align-items: center; /* Mittig horizontal */
      padding: 20px;
      box-sizing: border-box;
    }
    #right-header {
      font-size: 20px;
      font-weight: bold;
      margin-bottom: 20px;
    }
    #license {
      font-size: 10px;
      color: #333;
      text-align: left;
      margin-bottom: 20px;
    }
    #weblinks{
      align-items: left;
       
      font-size: 16px;
    }
    #drop-zone {
      width: 300px;
      height: 66px;
      border: 2px dashed #ccc;
      border-radius: 10px;
      text-align: center;
      line-height: 66px;
      color: #aaa;
      font-size: 16px;
      margin-bottom: 20px;
    }
    #drop-zone.hover {
      border-color: #333;
      color: #333;
    }
    #output {
        display: none;
        position: absolute;
        z-index: 1;
        top: 45%;
        left: 10%;
		width: 80%;
		height: 49%;
        padding: 5px;
        background-color: #feffe6;
        border: 2px solid #2196F3;
    }
    .comp-slider {
		position: absolute;
		z-index: 8;
        top: 50px;
		width: 40px;
		left: calc( 100% - 25px );			 		
	}
	.spinner {
        display: inline-block;
        width: 1em;
        height: 1em;
        border: 0.2em solid rgba(0,0,0,0.2);
        border-top-color: rgba(0,0,0,0.8);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }  

  </style>
</head>

<body>
<div id="main-container">

<!-- left: renderer -->
<div id="left-side">
    <!-- for canvas -->
</div>

<!-- right -->
<div id="right-side">
    <div id="right-header">
    Generation of SDFGeometry <br> (local)
    </div>
    <div >
        <p>
        &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;  &nbsp;&nbsp;  triangulation sequence >>>>>
        <br><br> 
        </p>
        
    </div>
    
    <div id="drop-zone">Drag SDF definition file (JSON) here.</div>

    <div id="loading" style="visibility: hidden;  margin-top:1em;">
        <span class="spinner"></span>  Triangulation is running... please wait
    </div>
    
    <div id="sliderArea" class="comp-slider" > 
    <input id="progress" type="range"  min="0" max="10000" value="10000"  style="height:500px; writing-mode: vertical-lr; direction: rtl"> 
    </div>
    
    <div id="exp">
        <br><br> 
        <button id="exportCode"> export geometry or GLTF </button> 
        <input id="nDec" type="number"  min="0" max="6" value="3" step="1" class="digits2" > decimals </br>
    </div>
    
    <div id="weblinks">
 
        <p>
        <a href="https://github.com/hofk" title="github hofk"  target="_blank">
        <img src="avatar.png" style="width: 72px; height: 72px" >programmed by hofk 
        </a>
        </p>
    </div>
    
    <a href="./Generation_of_SDFGeometry_EN.pdf" title="HELP"  target="_blank"> 
            <img src="./EN.png" style="width: 23px; height: 16px" > help
        </a>
        
    <div id="license">
         </br></br> 
         Copyright Klaus Hoffmeister https://hofk.de/  </br>
         Details at the top of the source code. 
     
    </div>

</div>

<div id="output" >
    <p  style="text-align: center;">
        
        <button id="downloadData">download data below</button>&nbsp;&nbsp;&nbsp;
        <button type="button" id="outX" style="color: #ff0000" > X </button> &nbsp;&nbsp;&nbsp;
        <button id="downloadGltf" style="display: none;" >download GLTF mesh</button> <br/>
        
    </p>
    
    <textarea id="exportLines"  style="width:98%; height:80%;"  > </textarea>

</div> 

<script type="module">

import * as THREE from "./jsm/three.module.180.js";
import { OrbitControls } from "./jsm/OrbitControls.180.js";
import { GLTFExporter } from './jsm/GLTFExporter.180.js';

// ....... adapted from GLSL ......................................    
const abs = ( x ) => Math.abs( x );
const sqrt = ( x ) => Math.sqrt( x );
const sin = ( x ) => Math.sin( x );
const cos = ( x ) => Math.cos( x );
const tan = ( x ) => Math.tan( x );
const log = ( x ) => Math.log( x );
const exp = ( x ) => Math.exp( x );
const atan2 = ( y, x ) => Math.atan2( y, x );
const pow = ( x, n ) => Math.pow( x, n );
const round = ( x ) => Math.round( x );
const sign = ( x ) => Math.sign( x );
const floor = ( x ) => Math.floor( x ); 
const floor3 = ( { x: x, y: y, z: z } ) => ( { x: floor( x ), y: floor( y ), z: floor( z ) } );
const min = ( x, y ) => Math.min( x, y );
const max = ( x, y ) => Math.max( x, y );
const clamp = ( x, a, b ) => max( a, min( x, b ) );
const mix = ( x, y, a ) => ( x * ( 1 - a) + y * a );
const min2 = ( { x: x, y: y } ) => min( x, y );
const max2 = ( { x: x, y: y } ) => max( x, y );
const max2Scalar = ( { x: x, y: y }, s ) => ( { x: max( x, s ), y: max( y, s ) } );
const max3Scalar = ( { x: x, y: y, z: z }, s ) => ( { x: max( x, s ), y: max( y, s ), z: max( z, s ) } );
const max3 = ( { x: x1, y: y1 }, { x: x2, y: y2 }  ) => ( { x: max( x1, x2 ), y: max( y1, y2 ), z: max( z1, z2 ) } );
const clamp3 = ( { x: x, y: y, z: z } ) =>  max( y, min( x, z ) );
                
const xy = ( { x: x, y: y, z: z } ) => ( { x: x,  y: y } );
const yx = ( { x: x, y: y, z: z } ) => ( { x: y,  y: x } );
const xz = ( { x: x, y: y, z: z } ) => ( { x: x,  y: z } );
const yz = ( { x: x, y: y, z: z } ) => ( { x: y,  y: z } );

const xyz = ( { x: x, y: y, z: z } ) => ( { x: x, y: y, z: z } );
const yzx = ( { x: x, y: y, z: z } ) => ( { x: y, y: z, z: x } );
const zxy = ( { x: x, y: y, z: z } ) => ( { x: z, y: x, z: y } );

const length2 = ( { x: x, y: y } ) => ( sqrt( x * x + y * y ) );
const length3 = ( { x: x, y: y, z: z } ) => ( sqrt( x * x + y * y + z * z ) );
const negate2 = ( { x: x, y: y } ) => ( { x: -x, y: -y } );
const negate3 = ( { x: x, y: y, z: z } ) => ( { x: -x, y: -y, z: -z } );

const dot2 = ( { x: x1, y: y1 }, { x: x2, y: y2 } ) => ( x1 * x2 + y1 * y2 );
const dot3 = ( { x: x1, y: y1, z: z1 }, { x: x2, y: y2, z: z2 } ) => ( x1 * x2 + y1 * y2 + z1 * z2 );

const dot2v = ( { x: x, y: y }  ) => ( x * x + y * y );
const dot3v = ( { x: x, y: y, z: z } ) => ( x * x + y * y + z * z );

const mul2 = ( { x: x1, y: y1 }, { x: x2, y: y2 }  ) => ( { x: x1 * x2, y: y1 * y2 } );
const mul3 = ( { x: x1, y: y1, z: z1 }, { x: x2, y: y2, z: z2 }  ) => ( { x: x1 * x2, y: y1 * y2, z: z1 * z2 } );
const mul2Scalar = ( { x: x, y: y}, s ) => ( { x: x * s, y: y * s } );
const mul3Scalar = ( { x: x, y: y, z: z }, s ) => ( { x: x * s, y: y * s, z: z * s } );
const div2 = ( { x: x1, y: y1 }, { x: x2, y: y2 } ) => ( { x: x1 / x2, y: y1 / y2 } );
const div3 = ( { x: x1, y: y1, z: z1 }, { x: x2, y: y2, z: z2 }  ) => ( { x: x1 / x2, y: y1 / y2, z: z1 / z2 } );
const div2Scalar = ( { x: x, y: y }, s ) => ( { x: x / s, y: y / s } );
const div3Scalar = ( { x: x, y: y, z: z }, s ) => ( { x: x / s, y: y / s, z: z / s } );

const normalize3 = ( { x: x, y: y, z: z } ) => ( { x: x / length3( { x, y, z } ), y: y / length3( { x, y, z } ), z: z / length3( { x, y, z } ) } );
const cross3 = ( { x: x1, y: y1, z: z1 }, { x: x2, y: y2, z: z2 } ) => ( { x: y1 * z2 - z1 * y2, y: z1 * x2 - x1 * z2, z: x1 * y2 - y1 * x2 } );
const add3  = ( { x: x1, y: y1, z: z1 }, { x: x2, y: y2, z: z2 } ) => ( { x: x1 + x2, y: y1 + y2, z: z1 + z2 } );
const add3Scalar = ( { x: x, y: y, z: z }, s ) => ( { x: x + s, y: y + s, z: z + s } );
const sub2  = ( { x: x1, y: y1 }, { x: x2, y: y2 } ) => ( { x: x1 - x2, y: y1 - y2 } );
const sub2Scalar = ( { x: x, y: y }, s ) => ( { x: x - s, y: y - s } );
const sub3  = ( { x: x1, y: y1, z: z1 }, { x: x2, y: y2, z: z2 } ) => ( { x: x1 - x2, y: y1 - y2, z: z1 - z2 } );
const sub3Scalar = ( { x: x, y: y, z: z }, s ) => ( { x: x - s, y: y - s, z: z - s } );
const abs3 = ( { x: x, y: y, z: z } ) => ( { x: abs( x ), y: abs( y ), z: abs( z ) } );
const abs2 = ( { x: x, y: y } ) => ( { x: abs( x ), y: abs( y ) } );

const PI = Math.PI;

// rotateX/Y/Z - angles in degrees
function rotateX(p, angle) {
  const ang = angle / 180.0 * PI;
  const s = sin(ang);
  const c = cos(ang);
  return {
    x: p.x,
    y: p.y * c - p.z * s,
    z: p.y * s + p.z * c
  };
}

function rotateY(p, angle) {
  const ang = angle / 180.0 * PI;
  const s = sin(ang);
  const c = cos(ang);
  return {
    x: p.x * c + p.z * s,
    y: p.y,
    z: -p.x * s + p.z * c
  };
}

function rotateZ(p, angle) {
  const ang = angle / 180.0 * PI;
  const s = sin(ang);
  const c = cos(ang);
  return {
    x: p.x * c - p.y * s,
    y: p.x * s + p.y * c,
    z: p.z
  };
}

function quatMul(q1, q2) {
  return {
    w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
    x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
    y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
    z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
  };
}

function quatConjugate(q) {
  return { w: q.w, x: -q.x, y: -q.y, z: -q.z };
}

function applyRotation(p, cfg) {
  if (cfg && cfg.quat != null) {
    const pQuat = { w: 0.0, x: p.x, y: p.y, z: p.z };
    const q = cfg.quat;
    //  rotation: p' = q⁻¹ * p * q
    const rotQ = quatConjugate(q);
    const invQ = q;
    const tmp = quatMul(rotQ, pQuat);
    const res = quatMul(tmp, invQ);
    return { x: res.x, y: res.y, z: res.z };
  }
  
  // Euler, also as a default 
  const x = cfg.rotx;
  const y = cfg.roty;
  const z = cfg.rotz;

  if (x !== 0 || y !== 0 || z !== 0) { // rotation exists
    const order = String(cfg.order).toUpperCase();
    switch (order) {
      case 'XYZ': return rotateZ( rotateY( rotateX(p, x), y), z);
      case 'XZY': return rotateY( rotateZ( rotateX(p, x), z), y);
      case 'YXZ': return rotateZ( rotateX( rotateY(p, y), x), z);
      case 'YZX': return rotateX( rotateZ( rotateY(p, y), z), x);
      case 'ZXY': return rotateY( rotateX( rotateZ(p, z), x), y);
      case 'ZYX': return rotateX( rotateY( rotateZ(p, z), y), x);
      default:    return rotateZ( rotateY( rotateX(p, x), y), z);
    }
  }
  return p;
}
 
function applyInverseRotation(p, cfg) {
  if (cfg && cfg.quat != null) {
    const pQuat = { w: 0.0, x: p.x, y: p.y, z: p.z };
    const q = cfg.quat;
    //  inverse rotation: p' = q * p * q⁻¹
    const rotQ = quatConjugate(q);
    const invQ = q;
    const tmp = quatMul(invQ, pQuat);
    const res = quatMul(tmp, rotQ);
    return { x: res.x, y: res.y, z: res.z };
  }
  
  // Euler, also as a default
  const x =  -cfg.rotx;
  const y =  -cfg.roty;
  const z =  -cfg.rotz;

  if (x !== 0 && y !== 0 && z !== 0) {
    const order =  String(cfg.order).toUpperCase();
    switch (order) {
      case 'ZYX': return rotateZ( rotateY( rotateX(p, x), y), z);
      case 'YZX': return rotateY( rotateZ( rotateX(p, x), z), y);
      case 'ZXY': return rotateZ( rotateX( rotateY(p, y), x), z);
      case 'XZY': return rotateX( rotateZ( rotateY(p, y), z), x);
      case 'YXZ': return rotateY( rotateX( rotateZ(p, z), x), y);
      case 'XYZ': return rotateX( rotateY( rotateZ(p, z), y), x);
      default:    return rotateZ( rotateY( rotateX(p, x), y), z);
    }
  }
  return p;
}

function applyBending(p, bend) {
  const angle = p.x * bend / 180.0 * PI;
  const c = cos(angle);
  const s = sin(angle);
  return {
    x: c * p.x - s * p.y,
    y: s * p.x + c * p.y,
    z: p.z
  };
}

// .......... functions used in  'concavesphere', 'cutbox' ..........
function myclamp(x, mn, mx) {
  return x < mn ? mn : (x > mx ? mx : x);
}

function mymix(a, b, t) {
  return a + (b - a) * t;
}

// smooth-min
function smin(a, b, k) {
  const h = myclamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mymix(b, a, h) - k * h * (1.0 - h);
}

//Smooth‐Min (blend for union)
function s_min(a, b, k) {
  const h = min(max(0.5 + 0.5 * (b - a) / k, 0.0), 1.0);
  return b * (1.0 - h) + a * h - k * h * (1.0 - h);
}

// Smooth‐Max (blend for intersection/subtraktion) 
function s_max(a, b, k) {
  return -s_min(-a, -b, k);
}

//   smooth Min Max
function smoothMin(x, y, k) {
  // blend for union
  const h = max(0.0, min(1.0, 0.5 + 0.5 * (y - x) / k));
  const mix = y * (1.0 - h) + x * h;
  return mix - k * h * (1.0 - h);
}

function smoothMax(a, b, k) {
  const h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

function ellipsoidSDF(pb, rxyz) {
    const q1 = div3(pb, rxyz);
    const k0 = length3(q1);
    const q2 = div3(pb, mul3(rxyz, rxyz));
    const k1 = length3(q2);
    return (k0 * (k0 - 1)) / k1;
}

function cylinderSDF(pb, rb, rt, h) {
  const q = { x: length2(xz(pb)), y: pb.y }; // q = (√(x²+z²), y)
  const k1 = { x: rt, y: h };
  const k2 = { x: rt - rb, y: 2.0 * h };
  const minRad = q.y < 0.0 ? rb : rt;
  const ca = { x: q.x - min(q.x, minRad), y: abs(q.y) - h };
  const dotNum = dot2(sub2(k1, q), k2);
  const dotDen = dot2v(k2);
  const t = clamp(dotNum / dotDen, 0.0, 1.0);
  const cb = { x: q.x - k1.x + k2.x * t, y: q.y - k1.y + k2.y * t };
  const sSign = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;
  const d2_ca = dot2v(ca);
  const d2_cb = dot2v(cb);
  const dist2 = min(d2_ca, d2_cb);
  const sdf3D = sSign * sqrt(dist2);
  return sdf3D;
}

// ---- Catmull-Rom Spline Helper ---- 
// centripetal Catmull-Rom spline (alpha = 0.5)
function spline(points, y, cfg) {
    const alpha = 0.5;
    const EPS = 1e-12;
    // defensive checks
    if (!Array.isArray(points) || points.length === 0) return 0.0;
    // normalize & ensure numeric
    const pts = Array.from(points);
    for (let i = 0; i < pts.length; i++) {
        if (!('h' in pts[i])) pts[i].h = 0.0;
        if (!('r' in pts[i])) pts[i].r = 0.0;
        pts[i].h = +pts[i].h;
        pts[i].r = +pts[i].r;
    }
    // ensure a point at h==0 with r==0
    let hasZero = false;
    for (const pt of pts) { if (abs(pt.h) < EPS) { hasZero = true; break; } }
    if (!hasZero) {
        pts.unshift({ h: 0.0, r: 0.0 });
    } else {
        for (let i = 0; i < pts.length; i++) {
            if (abs(pts[i].h) < EPS) { if (!('r' in pts[i])) pts[i].r = 0.0; break; }
        }
    }
    // sort by h ascending
    pts.sort((A, B) => A.h - B.h);
    const n = pts.length;
    // trivial cases
    if (n === 1) return pts[0].r;
    if (n === 2) {
        const h0 = pts[0].h, r0 = pts[0].r;
        const h1 = pts[1].h, r1 = pts[1].r;
        if (abs(h1 - h0) < EPS) return 0.5 * (r0 + r1);
        let t = (y - h0) / (h1 - h0);
        t = max(0.0, min(1.0, t));
        return r0 + (r1 - r0) * t;
    }
    // clamp / extrapolate behavior
    const extrapolate = (cfg && cfg.extrapolate) ? cfg.extrapolate : false;
    const hFirst = pts[0].h, rFirst = pts[0].r;
    const hLast = pts[n - 1].h, rLast = pts[n - 1].r;
    if (y <= hFirst) {
        if (extrapolate && n >= 2) {
            const h1 = pts[1].h, r1 = pts[1].r;
            if (abs(h1 - hFirst) < EPS) return rFirst;
            const t = (y - hFirst) / (h1 - hFirst);
            return rFirst + (r1 - rFirst) * t;
        }
        return rFirst;
    }
    if (y >= hLast) {
        if (extrapolate && n >= 2) {
            const h1 = pts[n - 2].h, r1 = pts[n - 2].r;
            if (abs(hLast - h1) < EPS) return rLast;
            const t = (y - h1) / (hLast - h1);
            return r1 + (rLast - r1) * t;
        }
        return rLast;
    }
    // find interval i such that h_i <= y <= h_{i+1}
    let iFound = -1;
    for (let i = 0; i < n - 1; i++) {
        if (y >= pts[i].h && y <= pts[i + 1].h) { iFound = i; break; }
    }
    if (iFound < 0) return rFirst;
    const i = iFound;
    // indices for control points p0..p3
    const i0 = max(0, i - 1);
    const i1 = i;
    const i2 = i + 1;
    const i3 = min(n - 1, i + 2);
    // fetch
    const h0 = pts[i0].h, r0 = pts[i0].r;
    const h1 = pts[i1].h, r1 = pts[i1].r;
    const h2 = pts[i2].h, r2 = pts[i2].r;
    const h3 = pts[i3].h, r3 = pts[i3].r;
    // knot param with alpha
    const t0 = 0.0;
    const t1 = t0 + pow(max(0.0, abs(h1 - h0)), alpha);
    const t2 = t1 + pow(max(0.0, abs(h2 - h1)), alpha);
    const t3 = t2 + pow(max(0.0, abs(h3 - h2)), alpha);
    // protect zero intervals
    if (t2 - t1 < EPS) {
        if (abs(h2 - h1) < EPS) return 0.5 * (r1 + r2);
        let u = (y - h1) / (h2 - h1);
        u = max(0.0, min(1.0, u));
        return r1 + (r2 - r1) * u;
    }
    // tangents m1,m2 per centripetal formula
    const den1 = max(EPS, t2 - t0);
    const den2 = max(EPS, t3 - t1);
    const m1 = ( (r2 - r1) / max(EPS, (t2 - t1))
               + (r1 - r0) / max(EPS, (t1 - t0)) )
             * ( (t2 - t1) / den1 );
    const m2 = ( (r3 - r2) / max(EPS, (t3 - t2))
               + (r2 - r1) / max(EPS, (t2 - t1)) )
             * ( (t2 - t1) / den2 );
    // map y in [h1,h2] to t in [t1,t2] linearly
    const u_linear = (y - h1) / max(EPS, (h2 - h1));  // in [0,1]
    let t = t1 + u_linear * (t2 - t1);
    // normalized u for Hermite
    let u = (t - t1) / max(EPS, (t2 - t1));
    u = max(0.0, min(1.0, u));
    // Hermite basis
    const h00 =  2.0 * u * u * u - 3.0 * u * u + 1.0;
    const h10 =      u * u * u - 2.0 * u * u + u;
    const h01 = -2.0 * u * u * u + 3.0 * u * u;
    const h11 =      u * u * u -     u * u;
    const scale = (t2 - t1);
    const M1 = m1 * scale;
    const M2 = m2 * scale;
    const result = h00 * r1 + h10 * M1 + h01 * r2 + h11 * M2;
    return result;
}
 
// ... SDF operations .....................................

function opUnion(fA, fB, k = 0.0) {
  return function(p) {
    const a = fA(p);
    const b = fB(p);
    if (!k || k <= 0.0) {
      return  min(a, b);
    }
    const diff =  abs(a - b);
    const h =  max(k - diff, 0.0) / k;
    return  min(a, b) - (h * h * k * 0.25);
  };
}

function opDynUnion(funcs, k = 0.0) {
  if (!Array.isArray(funcs) || funcs.length === 0) {
    return () => Infinity;
  }
  if (funcs.length === 1) return funcs[0];

  if (!k || k <= 0.0) {
    // no smoothing: just return the plain minimum
    return function(p) {
      let m = Infinity;
      for (let f of funcs) {
        const v = f(p);
        if (v < m) m = v;
      }
      return m;
    };
  }
  // smoothing: only the smallest and second smallest matter
  return function(p) {
    let m1 = Infinity, m2 = Infinity;
    for (let f of funcs) {
      const v = f(p);
      if (v < m1) { m2 = m1; m1 = v; }
      else if (v < m2) { m2 = v; }
    }
    const diff = abs(m1 - m2);
    const h = max(k - diff, 0.0) / k;
    return m1 - (h * h * k * 0.25);
  };
}

function opSubtraction(sdf1, sdf2, s) {
  return function(p) {
    const d1 = sdf2(p); // swapped  op1 - op2
    const d2 = sdf1(p);
    if (s <= 0.0) return max(-d1, d2);
    const h = clamp(0.5 - 0.5 * (d2 + d1) / s, 0.0, 1.0);
    return mix(d2, -d1, h) + s * h * (1.0 - h);
  };
}

function opDynSubtraction(funcs, s = 0.0) {
  if (!Array.isArray(funcs) || funcs.length === 0) {
    return () => Infinity;
  }
  if (funcs.length === 1) return funcs[0];

  let current = funcs[0];
  for (let i = 1; i < funcs.length; ++i) {
    current = opSubtraction(current, funcs[i], s);
  }
  return current;
}

function opIntersection(sdf1, sdf2, s) {
  return function(p) {
    const d1 = sdf1(p);
    const d2 = sdf2(p);
    if (s <= 0.0) return max(d1, d2);
    const h = clamp(0.5 - 0.5 * (d2 - d1) / s, 0.0, 1.0);
    return mix(d2, d1, h) + s * h * (1.0 - h);
  };
}

function opBlending(sdf1, sdf2, b, s) {
  return function(p) {
    const d1 = sdf1(p);
    const d2 = sdf2(p);
    const dMix = mix(d1, d2, b);
    return dMix - s * b * (1.0 - b);
  };
}
                    
function opSection(sdf, planes, s) {
  return function(p) {
    let sd = sdf(p);
    for (const pl of planes) {
      const n = normalize3(pl.normal); 
      const d = pl.d - 0.75 * s; // compensated plane shift
      const sdPlane = dot3(p, n) - d;
      if (sd === 0.0) {
        sd = sdPlane;
      } else {
        sd = -smoothMin(-sd, -sdPlane, s);
      }
    }
    return sd - s;
  };
}

function opElongateX(sdf, d) {
  return function(p) {
    // inside: Y, Z remain, X is symmetrized and shifted by d
    const absX    = abs(p.x);
    const xInner  = absX - d;
    const xClipped = max(xInner, 0.0);
    const qInner  = { x: xClipped, y: p.y, z: p.z };
    const dInside = sdf(qInner);
    // outside flanks: abs on all axes
    const q0       = { x: xInner, y: abs(p.y), z: abs(p.z) };
    const dOutside = min( max(q0.x, max(q0.y, q0.z)), 0.0 );
    return dInside + dOutside;
  };
}

function opElongateY(sdf, d) {
  return function(p) {
    const absY    = abs(p.y);
    const yInner  = absY - d;
    const yClipped = max(yInner, 0.0);
    const qInner  = { x: p.x, y: yClipped, z: p.z };
    const dInside = sdf(qInner);
    const q0       = { x: abs(p.x), y: yInner, z: abs(p.z) };
    const dOutside = min( max(q0.x, max(q0.y, q0.z)), 0.0 );
    return dInside + dOutside;
  };
}

function opElongateZ(sdf, d) {
  return function(p) {
    const absZ   = abs(p.z);
    const zInner = absZ - d;
    const zClipped = max(zInner, 0.0);
    const qInner   = { x: p.x, y: p.y, z: zClipped };
    const dInside  = sdf(qInner);
    const q0       = { x: abs(p.x), y: abs(p.y), z: zInner };
    const dOutside = min( max(q0.x, max(q0.y, q0.z)), 0.0 );
    return dInside + dOutside;
  };
}

function opScale(sdf, scale) {
  return function(p) {
    const q = div3(p, scale);
    const d = sdf(q);
    const k = min(scale.x, min(scale.y, scale.z));
    return d * k;
  };
}

function opLimitedRepetition(sdf, d, nnn) {
  return function(p) {
    const n3 = floor3(div3Scalar(nnn, 2)); // Wiederholungen pro Richtung
    const rx = round(p.x / d);
    const ry = round(p.y / d);
    const rz = round(p.z / d);
    const cx = max(-n3.x, min(n3.x, rx));
    const cy = max(-n3.y, min(n3.y, ry));
    const cz = max(-n3.z, min(n3.z, rz));
    const offset = { x: d * cx, y: d * cy, z: d * cz };
    const q = sub3(p, offset);
    return sdf(q);
  };
}

function opDisplace(sdf, func, d, f) {
  return function(p) {
    const d1 = sdf(p);
    const FUNC = String(func).toUpperCase();
    const Pi2 = PI * 2;
    let d2 = 0.0;
    switch (FUNC) {
      case 'SINX':
        d2 = d * sin(Pi2 * f * p.x);
        break;
      case 'SINY':
        d2 = d * sin(Pi2 * f * p.y);
        break;
      case 'SINZ':
        d2 = d * sin(Pi2 * f * p.z);
        break;
      case 'SINXY':
        d2 = d * sin(Pi2 * f * p.x) * sin(Pi2 * f * p.y);
        break;
      case 'SINXZ':
        d2 = d * sin(Pi2 * f * p.x) * sin(Pi2 * f * p.z);
        break;
      case 'SINYZ':
        d2 = d * sin(Pi2 * f * p.y) * sin(Pi2 * f * p.z);
        break;
      case 'SINXYZ':
        d2 = d * sin(Pi2 * f * p.x) * sin(Pi2 * f * p.y) * sin(Pi2 * f * p.z);
        break;
      case 'FBM': {
        let amp = 1.0;
        let freq = f;
        let n = 0.0;
        for (let i = 0; i < 4; i++) {
          n += amp * sin(Pi2 * freq * p.x) * sin(Pi2 * freq * p.y) * sin(Pi2 * freq * p.z);
          amp *= 0.5;
          freq *= 2.0;
        }
        d2 = d * n;
      } break;
      case 'SINFBM': {
        let sum = 0.0;
        let amp = 1.0;
        let freq = f;
        for (let i = 0; i < 5; i++) {
          sum += amp * ( sin(freq * p.x) + sin(freq * p.y) + sin(freq * p.z) ) / 3.0;
          amp *= 0.5;
          freq *= 2.0;
        }
        d2 = d * sum;
      } break;
      case 'SINRND': {
        let sum = 0.0;
        let amp = d;
        const freq = f * Pi2;
        const dirs = [
          { x: 0.8, y: 0.1, z: 0.5 },
          { x: -0.3, y: 0.7, z: 0.6 },
          { x: 0.6, y: -0.4, z: 0.7 },
          { x: -0.5, y: 0.9, z: -0.1 },
          { x: 0.2, y: 0.4, z: -0.8 },
        ];
        for (let i = 0; i < dirs.length; i++) {
          const nDir = dirs[i];
          const len = sqrt(nDir.x * nDir.x + nDir.y * nDir.y + nDir.z * nDir.z);
          const dx = nDir.x / len, dy = nDir.y / len, dz = nDir.z / len;
          const dot = dx * p.x + dy * p.y + dz * p.z + i;
          sum += amp * sin(freq * dot);
          amp *= 0.8;
        }
        d2 = sum;
      } break;
      default:
        d2 = 0.0;
    }
    return d1 + d2;
  };
}

function opRotation(sdf, cfg) {
    const rotatedSDF = function(p) {
    const pc = sub3(p, cfg.c); // cfg.c is pivot
    const pr = applyRotation(pc, cfg);
    return sdf(pr);
  };
  rotatedSDF._cfg = { c: cfg.c }; // pivot 
  return rotatedSDF;
}

function opTranslation(sdf, cfg) {
    const tranlatedSDF = function(p) {
    const pc = sub3(p, cfg.c); 
    return sdf(pc);
  };
  tranlatedSDF._cfg = { c: cfg.c }; // // cfg.c is new center
  return tranlatedSDF;
}

function opMirrorXY(sdf) {
  return function(p) {
    p.z = -p.z;
    return sdf(p);
  };
}

function opMirrorXZ(sdf) {
  return function(p) {
    p.y = -p.y;
    return sdf(p);
  };
}

function opMirrorYZ(sdf) {
  return function(p) {
    p.x = -p.x;
    return sdf(p);
  };
}

function opMirrorPlane(sdf, nUn, d) {
  const n = normalize3(nUn);
  return function(p) {
    const t = dot3(p, n) - d;
    const pRef = sub3(p, mul3Scalar(n, 2.0 * t));
    return sdf(pRef);
  };
}

// distort helper
function noise3d(p, scale) {
  const x0 = floor(p.x * scale); const x1 = x0 + 1;
  const y0 = floor(p.y * scale); const y1 = y0 + 1;
  const z0 = floor(p.z * scale); const z1 = z0 + 1;
  const fx = p.x * scale - x0; const fy = p.y * scale - y0; const fz = p.z * scale - z0;
  const fade = (t) => { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); };
  const u = fade(fx); const v = fade(fy); const w = fade(fz);
  const hash = (xi, yi, zi) => {
    const h = sin(xi * 127.1 + yi * 311.7 + zi * 74.7) * 43758.5453;
    return h - floor(h);
  };
  const c000 = hash(x0, y0, z0); const c100 = hash(x1, y0, z0);
  const c010 = hash(x0, y1, z0); const c110 = hash(x1, y1, z0);
  const c001 = hash(x0, y0, z1); const c101 = hash(x1, y0, z1);
  const c011 = hash(x0, y1, z1); const c111 = hash(x1, y1, z1);
  const mixLocal = (a, b, t) => { return a * (1.0 - t) + b * t; };
  const c00 = mixLocal(c000, c100, u);
  const c10 = mixLocal(c010, c110, u);
  const c01 = mixLocal(c001, c101, u);
  const c11 = mixLocal(c011, c111, u);
  const c0 = mixLocal(c00, c10, v);
  const c1 = mixLocal(c01, c11, v);
  return mixLocal(c0, c1, w) * 2.0 - 1.0;
}

function opDistort(sdf, mode, dxyz, fxyz) {
  return function(p) {
    switch (String(mode).toLowerCase()) {
      case 'sin': {
        const dx = dxyz.x * sin(fxyz.x * p.x);
        const dy = dxyz.y * sin(fxyz.y * p.y);
        const dz = dxyz.z * sin(fxyz.z * p.z);
        const disp = { x: dx, y: dy, z: dz };
        const q = { x: p.x + disp.x, y: p.y + disp.y, z: p.z + disp.z };
        return sdf(q);
      }
      case 'noise': {
        const n = noise3d(p, fxyz.y);
        const disp = { x: dxyz.x * n, y: dxyz.y * n, z: dxyz.z * n };
        const q = { x: p.x + disp.x, y: p.y + disp.y, z: p.z + disp.z };
        return sdf(q);
      }
      case 'vnoise': { 
        const nx = noise3d(p, fxyz.x);
        const ny = noise3d(p, fxyz.y);
        const nz = noise3d(p, fxyz.z);
        const disp = {
          x: dxyz.x * nx,
          y: dxyz.y * ny,
          z: dxyz.z * nz
        };
        const q = {
          x: p.x + disp.x,
          y: p.y + disp.y,
          z: p.z + disp.z
        };
        return sdf(q);
      }
      case 'twist': {
        // twist um Y-Achse: winkel = f.y * p.y
        const angle = fxyz.y * p.y;
        const ca = cos(angle); const sa = sin(angle);
        const x2 = p.x * ca - p.z * sa;
        const z2 = p.x * sa + p.z * ca;
        // interpolation zwischen original und twisted
        const t = clamp(dxyz.y, 0.0, 1.0); // d.y∈[0,1]
        return sdf({
          x: p.x * (1 - t) + x2 * t,
          y: p.y,
          z: p.z * (1 - t) + z2 * t
        });
      }
      case 'pinch': {
        const f = 1.0 + dxyz.y * sin(fxyz.y * p.y);
        const disp = { x: (f - 1) * p.x, y: 0.0, z: (f - 1) * p.z };
        const q = { x: p.x + disp.x, y: p.y + disp.y, z: p.z + disp.z };
        return sdf(q);
      }
      default:
        return sdf(p);
    }
    
    // for sin/noise/pinch
    if (typeof disp !== 'undefined') {
        const q = { x: p.x + disp.x, y: p.y + disp.y, z: p.z + disp.z };
        return sdf(q);
    }
  };
}

function opExtrusion(p, sdf2D, d) {
  const w = { x: sdf2D, y: abs(p.z) - d };
  return min(max(w.x, w.y), 0.0) + length2(max2Scalar(w, 0.0));
}

function opRevolution(p, w) {
  const r = sqrt(p.x * p.x + p.z * p.z) - w;
  return { x: r, y: p.y };
}

// .... for triangulation .......
const squareLength = ( x,y,z ) => ( x*x + y*y + z*z );
const length = ( x,y,z ) => ( sqrt( x*x + y*y + z*z ) );
const prevFront = ( i ) => ( i !== 0 ? i - 1 : front.length - 1 );
const nextFront = ( i ) => ( i !== front.length - 1 ? i + 1 : 0 );
const determinant = ( xa,ya,za, xb,yb,zb, xc,yc,zc ) => ( xa*yb*zc + ya*zb*xc + za*xb*yc - za*yb*xc - xa*zb*yc - ya*xb*zc );
// ..............................

let m; // index of the current front point
let n; // number of new points
let nT; // number of new triangles
let nIns; // number of new points (after union or split)
let dAng; // partial angle
let phi; // angle (new points)
let len, d1, d2, d12; // lengths
let split, iSplit, jSplit; // split front indices  
let unite, iUnite, jUnite, fUnite; // unite front indices, front number (to unite) 

// points and vectors:
let xp, yp, zp; // actual point p
let x1, y1, z1, x2, y2, z2; // previous and next point to p in front
let xn, yn, zn; // partial derivations on point p, normal, gradient
let xt1, yt1, zt1, xt2, yt2, zt2; // tangents
let xs1, ys1, xs2, ys2; // p in tangential system (only x, y required)
let xc, yc, zc; // actual point as center point for new points

let d, dd; // distance, distance squared
 
let frontStock, frontNo, frontPosIdx, unionIdxA, unionIdxB, splitIdx;

let settings, tsl, maxDistance, startPoint, direction;

//let pc, pr, pb;

let front = []; // active front // front[ i ]: object { idx: 0, ang: 0 }
let partFront = []; // separated part of the active front (to split)
let insertFront = []; // new front points to insert into active front
let fronts = []; // all fronts
let partBounds = []; // bounding box of partFront [ xmin, ymin, zmin, xmax, ymax, zmax ]
let boundings = []; // fronts bounding boxes
let smallAngles = []; // new angles < 1.5

// .....................................................

let type, c, r, s, execute, op1, op2;

const DEFAULTS = {
  type: null,
  c: { x: 0.0, y: 0.0, z: 0.0 },    // center
  whd: { x: 1.0, y: 1.0, z: 1.0 },  // width, height, depth
  h: 1.0,                           // height
  d: 1.0,                           // depth, distance, displace (default only for depth) 
  r: 1.0,                           // radius
  R: 2.0,                           // great radius
  rb: 1.0,                          // radius bottom
  rt: 0.5,                          // radius top
  rxyz: { x: 0.6, y: 1.0, z: 0.6 }, // radius x, y, z
  from: null,                       // capsule start
  to: null,                         // capsule end
  bev: 0.25,                        // bevelbox
  fx: null,                         // frame x (boxframe)
  fy: null,                         // frame y (boxframe)
  fz: null,                         // frame z (boxframe)
  f: null,                          // frame (cross), frequency (displace, rotate)
  a: 1.0,                           // factor (paraboloid, powerparaboloid)
  mode: 'sin',                      // modus (distort)
  dxyz: null,                       // differences (distort)
  fxyz: null,                       // frequencies (distort)
  n: 3,                             // number (prism, edges), power exponent
  nnn: { x: 3, y: 3, z: 3 },        // numbers (repeat)
  '°': 45,                          // angle in degrees
  rotx: 0.0,                        // rotation x
  roty: 0.0,                        // rotation y
  rotz: 0.0,                        // rotation z
  order: 'XYZ',                     // Euler order
  quat: null,                       // quaternion (if used)
  bend: 0.0,                        // bend factor in degrees (x direction)
  points: null,                     // array of 2D points
  planes: null,                     // array of section planes [{normal,d},...]
  normal: null,                     // plane normal
  func: null,                       // displace / rotate function
  shape: null,                      // 2D shape for extrude/revolute
  op: null,                         // operand (generic)
  op1: null,                        // operand 1
  op2: null,                        // operand 2
  b: 0.5,                           // blending factor (0..1)
  s: 0.08,                          // smoothness (edge, operations)
  hollow: true,                     // hollow form
  execute: false
};

let posIdx = 0;
let indIdx = 0;

// ........  drag & drop  ..........................................
const dropZone = document.getElementById('drop-zone');

//const resultBox = document.getElementById('result');

// prevent defaults
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
  dropZone.addEventListener(eventName, (e) => {
    e.preventDefault();
    e.stopPropagation();
  }, false);
});

// hover
['dragenter', 'dragover'].forEach(eventName => {
  dropZone.addEventListener(eventName, () => {
    dropZone.classList.add('hover');
  }, false);
});
['dragleave', 'drop'].forEach(eventName => {
  dropZone.addEventListener(eventName, () => {
    dropZone.classList.remove('hover');
  }, false);
});

// when dropping - read file, send to server
dropZone.addEventListener('drop', handleDrop, false);

const progress = document.getElementById('progress');

progress.addEventListener( 'input', (e) => {
    progress.max = g.indices.length;
    g.setDrawRange( 0, e.target.value  );    
});
 
const exporter = new GLTFExporter( );
document.getElementById("exportCode").onpointerup = exportJavaScript;
document.getElementById( "outX" ).onpointerup = hideOutput;
const output = document.getElementById( "output" );

const exportLines = document.getElementById( "exportLines" );
document.getElementById( 'downloadData' ).onpointerup = ( ) => saveString( exportLines.value, 'data.txt' );
document.getElementById( 'downloadGltf' ).onpointerup = downloadMeshGltf;

const linkElem = document.createElement( 'a' );
linkElem.style.display = 'none';
document.body.appendChild( linkElem ); // Firefox workaround

//.....................................................

const splitRend = 0.8; // renderer left 80%,  right20%
const scene = new THREE.Scene();
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setClearColor( 0xdedede );
renderer.setSize( splitRend * window.innerWidth , window.innerHeight );
document.getElementById('left-side').appendChild(renderer.domElement);
const camera = new THREE.PerspectiveCamera(65, ( splitRend * window.innerWidth ) / window.innerHeight, 0.1, 1000);
camera.position.set( 1, 1, 5 );

const controls = new OrbitControls(camera, renderer.domElement);

const light = new THREE.AmbientLight( 0x404040, 4.5 ); // soft white light
scene.add( light );

const axesHelper = new THREE.AxesHelper( 1.00 );// 1.25
scene.add( axesHelper );
 
 
//... material .........................................................
 
const material3Dwire = new THREE.MeshBasicMaterial({
    side: THREE.DoubleSide, color: 0x023304, transparent: true, opacity: 0.85, wireframe: true 
});

// https://discourse.threejs.org/t/how-to-have-different-colors-textures-on-bottom-and-top-side-of-a-plane/12644/17

const material2Colors = new THREE.MeshBasicMaterial({
  color: 0x009e00,  
  transparent: true,
  opacity: 0.85,
  forceSinglePass: true,
  side: THREE.DoubleSide,
  onBeforeCompile: shader => {
    shader.uniforms.backColor = { value: new THREE.Color(0xffe400)};
    shader.fragmentShader = `
      uniform vec3 backColor;
      ${shader.fragmentShader}
    `.replace(
      `vec4 diffuseColor = vec4( diffuse, opacity );`,
      `
      vec3 col = gl_FrontFacing ? diffuse : backColor;
      vec4 diffuseColor = vec4( col, opacity );
      `
    );
  }
});

let g, SDF, SDFmesh, SDFmeshWire, out;

animate( );

//........................................................

function animate( ) {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

function handleDrop(e) {
  const dt = e.dataTransfer;
  const files = dt.files;
  if (files.length > 0) {
    dropZone.style.visibility = 'hidden';
    document.getElementById('loading').style.visibility = 'visible'; 
    
    setTimeout(() => {
    
        processUploadedJSONFile(files[0]).catch(err => { 
        alert('Error reading the file: ' + (err && err.message ? err.message : String(err)));
        });
        
    }, 20);
    
  }
}

//  Read, parse, and process file 
async function processUploadedJSONFile(file) {
      
    if ( SDFmesh ) {
        scene.remove(SDFmesh);  
    }
    if ( SDFmeshWire ) {
        scene.remove( SDFmeshWire);  
    }
    
    g = new THREE.BufferGeometry();
    
    g.indices = [];
    g.positions = [];
    g.normals = [];
    
    SDFmesh = new THREE.Mesh( g, material2Colors );
    scene.add( SDFmesh );
    SDFmeshWire = new THREE.Mesh( g, material3Dwire );
    scene.add( SDFmeshWire );
     
    const text = await readFileAsText(file);
    let params;
    try {
        params = JSON.parse(text);
    } catch (e) {
        throw new Error('no JSON: ' + e.message);
    }
    
    // copy settings with defaults
    settings = (params.Settings && { ...params.Settings }) || {};
    tsl = settings.tsl ?? 0.05;
    maxDistance = settings.maxDistance ?? 1000.0;
    startPoint = settings.startPoint ?? { x: 0.0, y: 0.0, z: -1000.0 };
    direction = settings.direction ?? { x: 0.0, y: 0.0, z: 1.0 };
    
    // remove Settings => remaining entries are the sdf objects
    const sdfObjects = { ...params };
    delete sdfObjects.Settings;
    
    // apply common defaults to each object (shallow merge)
    const remaining = {};
    for (const id of Object.keys(sdfObjects)) {
        const raw = sdfObjects[id] || {};
        const cfg = {};
        for (const k of Object.keys(DEFAULTS)) {
            cfg[k] = raw.hasOwnProperty(k) ? raw[k] : DEFAULTS[k];
        }
        // copy additional fields if any
        for (const k of Object.keys(raw)) {
            if (!cfg.hasOwnProperty(k)) cfg[k] = raw[k];
        }
        remaining[id] = cfg;
    }
    
    // select execute ids (those with execute truthy), if none -> last entry
    const executeIds = [];
    for (const [id, cfg] of Object.entries(remaining)) {
        if (cfg.execute) executeIds.push(id);
    }
    if (executeIds.length === 0) {
        const keys = Object.keys(remaining);
        if (keys.length > 0) executeIds.push(keys[keys.length - 1]);
    }
    const executeId = executeIds[executeIds.length - 1];
    
    const sdfFunctions = {};
    let progress;
    while (Object.keys(remaining).length > 0){
        progress = false;
        for (const [id, cfg] of Object.entries({ ...remaining })) {
            switch (cfg.type) {          
                case 'sphere':
                    sdfFunctions[id] = function(p){
                        const pc = sub3(p, cfg.c);
                        return length3( pc ) - cfg.r;
                    };  
                    delete remaining[id];
                    progress = true;
                    break;                   
                case 'hemisphere':
                    sdfFunctions[id] = function(p) {
                        const r = cfg.r - cfg.s;
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const len = length3(pr);
                        const sdfSphere = len - r;
                        const sdfHalf = -pr.y; //   y>=0  
                        const sdf3D = max(sdfSphere, sdfHalf);
                        return sdf3D - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                
                case 'cutsphere':
                    sdfFunctions[id] = function(p) {
                        const r = cfg.r - cfg.s; // fix wie cfg.s default
                        const h = cfg.h * r;
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const len = length3(pr);
                        const sdfSphere = len - r;
                        const sdfHalf = -(pr.y + h); //   y>=0,
                        const sdf3D = max(sdfSphere, sdfHalf);
                        return sdf3D - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;              
                case 'hollowsphere':
                    sdfFunctions[id] = function(p) {
                        let R = cfg.R;
                        const r = cfg.r;
                        let h = cfg.h - R;
                        let t = (R - r) / 2;
                        R = R - t;
                        t = t / 2;
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend );
                        const w =sqrt(max(0, R*R - h*h));
                        const q = {
                            x: length2({ x: pb.x, y: pb.z }),
                            y: pb.y
                        };
                        let sdf;
                        if (h * q.x < w * q.y) {
                            const dx = q.x - w;
                            const dy = q.y - h;
                            sdf =  sqrt(dx*dx + dy*dy);
                        } else {
                            const distToSphere = sqrt(q.x * q.x + q.y * q.y) - R;
                            sdf = abs(distToSphere);
                        }
                        return sdf - t;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'concavesphere':
                    sdfFunctions[id] = function(p) {
                        const s  = cfg.s;
                        const r  = cfg.r;
                        const pc = sub3(p, cfg.c);
                        let pr  = applyRotation(pc, cfg);
                        pr  = abs3(pr );
                        const d = clamp(cfg.d, 0.0, r);
                        const d_sphere = length3(pr) - r;
                        const p2 = sub3(pr, { x: r, y: r, z: r });
                        const d2 = length3(p2) - r;
                        const d_concave = -smin(-d_sphere, d2, s);
                        const t = d / r; // [0..1] 
                        return mix(d_sphere, d_concave, t);
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'solidangle':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const scx = sin(cfg['°'] / 180.0 * PI);
                        const scy = cos(cfg['°'] / 180.0 * PI);
                        const c = { x: scx, y: scy };
                        const q = {
                            x: length2({ x: pb.x, y: pb.z }),
                            y: pb.y
                        };
                        const l = length2(q) - cfg.r;
                        const dot_qc = dot2(q, c);
                        const clamped = max(0.0, min(dot_qc, cfg.r));
                        const proj = { x: c.x * clamped, y: c.y * clamped };
                        const diff = { x: q.x - proj.x, y: q.y - proj.y };
                        const m = length2(diff);
                        const signTerm = c.y * q.x - c.x * q.y;
                        const sgn = signTerm >= 0.0 ? 1.0 : -1.0;
                        return max(l, m * sgn);
                    };
                    delete remaining[id];
                    progress = true;
                    break;                               
                case 'ellipsoid':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const sdf3D = ellipsoidSDF(pb, cfg.rxyz);
                        return sdf3D;
                    };
                    delete remaining[id];
                    progress = true;
                    break;               
                case 'torus':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const q = {
                            x: length3({ x: pb.x, y: 0, z: pb.z }) - cfg.R,
                            y: pb.y
                        };
                        return length2(q) - cfg.r;
                    };
                    delete remaining[id];
                    progress = true;
                    break;   
                case 'cappedtorus':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const xAbs = abs(pb.x);
                        const scx = sin(cfg['°'] / 180 * PI);
                        const scy = cos(cfg['°'] / 180 * PI);
                        const q = { x: xAbs, y: pb.z };
                        let k;
                        if (scy * q.x > scx * q.y) {
                            k = dot2(q, { x: scx, y: scy });
                        } else {
                            k = length2(q);
                        }
                        const sum2 = dot3v(pb) + cfg.R * cfg.R - 2.0 * cfg.R * k;
                        const sdf3D = sqrt(sum2) - cfg.r;
                        return sdf3D;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'link':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const absZ = abs(pb.z);  // |p.z| for the straight middle part
                        const dQuarter = cfg.d / 4;
                        const qy = max(absZ - dQuarter, 0.0);
                        const q = {
                            x: pb.x,
                            y: qy,
                            z: pb.y
                        };
                        const radial = length2({ x: q.x, y: q.y }); // radial displacement in the x–z plane
                        const sdf3D = length2({
                            x: radial - cfg.R,
                            y: q.z
                        }) - cfg.r;
                        return sdf3D;
                    };
                    delete remaining[id];
                    progress = true;
                    break;                
                case 'capsule':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        if (cfg.from !== undefined && cfg.from !== null && cfg.to !== undefined && cfg.to !== null) {
                            const a = cfg.from;
                            const b = cfg.to;
                            const pa = sub3(pb, a);
                            const ba = sub3(b, a);
                            const h = clamp(dot3(pa, ba) / dot3(ba, ba), 0.0, 1.0);
                            const proj = mul3Scalar(ba, h);
                            const d3 = sub3(pa, proj);
                            const sdf3D = length3(d3) - cfg.r;
                            return sdf3D;
                        } else {
                            const h = cfg.h - 2 * cfg.r;
                            const yClamped = clamp(pb.y, 0.0, h);
                            const p3 = {
                                x: pb.x,
                                y: pb.y - yClamped,
                                z: pb.z
                            };
                            return length3(p3) - cfg.r;
                        }
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'cylinder':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const sdf3D = cylinderSDF(pb, cfg.rb, cfg.rt, cfg.h);
                        return sdf3D - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;                    
                case 'box':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c); 
                        const pr = applyRotation(pc, cfg); 
                        const pb = applyBending(pr, cfg.bend); 
                        const q  = sub3(abs3(pb), div3Scalar(cfg.whd, 2)); 
                        return length3(max3Scalar(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;                
                case 'bevelbox':
                    sdfFunctions[id] = function(p) {
                        const pc      = sub3(p, cfg.c);
                        const pr      = applyRotation(pc, cfg);
                        const p_loc   = applyBending(pr, cfg.bend);
                        let p2        = xy(p_loc);
                        p2            = abs2(p2);
                        const wh      = xy(cfg.whd);
                        p2            = sub2(p2, wh);
                        p2            = (p2.y > p2.x) ? yx(p2) : xy(p2);
                        p2.y         += cfg.bev;
                        const k       = 1.0 - sqrt(2.0);
                        let sdf2D;
                        if (p2.y < 0.0 && p2.y + p2.x * k < 0.0) {
                            sdf2D = p2.x;
                        } else if (p2.x < p2.y) {
                            sdf2D = (p2.x + p2.y) * sqrt(0.5);
                        } else {
                            sdf2D = length2(p2);
                        }
                        const d = cfg.whd.z / 2;
                        return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'cutbox':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const q  = sub3(abs3(pb), div3Scalar(cfg.whd, 2));
                        const box = length3(max3Scalar(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
                        const n = normalize3({ x: 0, y: 1, z: 0 });
                        const d = cfg.d + cfg.s;                    // dist from origin 
                        const sdPlane = dot3(pb, n) - d;
                        const sd = max(box, sdPlane);  // cut by plane
                        return sd - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'boxframe':
                    const outer = function(p) {
                        const pc = sub3(p, cfg.c);                
                        const pr = applyRotation(pc, cfg);        
                        const pb = applyBending(pr, cfg.bend);    
                        const half = div3Scalar(cfg.whd, 2.0);    
                        const q0   = sub3(abs3(pb), half);        
                        return length3(max3Scalar(q0, 0.0))       
                            + min(max(q0.x, max(q0.y, q0.z)), 0.0)
                            - cfg.s;                              
                    };
                    
                    const innerSDFs = [];
                    if (cfg.fx !== null) {
                        innerSDFs.push(function(p) {
                            const pc = sub3(p, cfg.c);                          
                            const pr = applyRotation(pc, cfg);                  
                            const pb = applyBending(pr, cfg.bend);              
                            const half = div3Scalar(cfg.whd, 2.0);              
                            const b_yz = sub2Scalar(yz(half), cfg.fx);          
                            const q    = sub2(abs2({ x: pb.y, y: pb.z }), b_yz);
                            const pos  = max2Scalar(q, 0.0);                    
                            return length2(pos)                                 
                                + min(max(q.x, q.y), 0.0)                       
                                - cfg.s;                                        
                        });
                    }
                    
                    if (cfg.fy !== null) {
                        innerSDFs.push(function(p) {
                            const pc = sub3(p, cfg.c);                          
                            const pr = applyRotation(pc, cfg);                  
                            const pb = applyBending(pr, cfg.bend);              
                            const half = div3Scalar(cfg.whd, 2.0);              
                            const b_xz = sub2Scalar(xz(half), cfg.fy);          
                            const q    = sub2(abs2({ x: pb.x, y: pb.z }), b_xz);
                            const pos  = max2Scalar(q, 0.0);                    
                            return length2(pos)                                 
                                + min(max(q.x, q.y), 0.0)                       
                                - cfg.s;                                        
                        });
                    }
                    if (cfg.fz !== null) {
                        innerSDFs.push(function(p) {
                            const pc = sub3(p, cfg.c);                
                            const pr = applyRotation(pc, cfg);        
                            const pb = applyBending(pr, cfg.bend);    
                            const half = div3Scalar(cfg.whd, 2.0);    
                            const b_xy = sub2Scalar(xy(half), cfg.fz);
                            const q    = sub2(abs2(xy(pb)), b_xy);    
                            const pos  = max2Scalar(q, 0.0);          
                            return length2(pos)                       
                                + min(max(q.x, q.y), 0.0)             
                                - cfg.s;                              
                        });
                    }
                    
                    if (innerSDFs.length === 0) {
                        sdfFunctions[id] = outer;
                    } else if (innerSDFs.length === 1) {
                        sdfFunctions[id] = opSubtraction(outer, innerSDFs[0], cfg.s);
                    } else {
                        let unionInner = innerSDFs.shift();
                        for (const inner of innerSDFs) {
                            unionInner = opUnion(unionInner, inner, cfg.s);
                        }
                        sdfFunctions[id] = opSubtraction(outer, unionInner, cfg.s);
                    }
                    delete remaining[id];
                    progress = true;
                    break;                   
                case 'cross':
                    const rotz = cfg.rotz;
                    const boxA = function(p) {
                        cfg.rotz = rotz + 0.5 * cfg['°'];
                        const pc = sub3(p, cfg.c);             
                        const pr = applyRotation(pc, cfg);     
                        const pb = applyBending(pr, cfg.bend); 
                        const half = div3Scalar({ x: cfg.f, y: cfg.r, z: cfg.d }, 2.0); 
                        const q  = sub3(abs3(pb), half);       
                        return length3(max3Scalar(q, 0.0))     
                            + min(max(q.x, max(q.y, q.z)), 0.0)
                            - cfg.s;                           
                    };
                    const boxB = function(p) {
                        cfg.rotz = rotz - 0.5 * cfg['°']; 
                        const pc = sub3(p, cfg.c);             
                        const pr = applyRotation(pc, cfg);     
                        const pb = applyBending(pr, cfg.bend); 
                        const half = div3Scalar({ x: cfg.f, y: cfg.r, z: cfg.d }, 2.0); 
                        const q  = sub3(abs3(pb), half);       
                        return length3(max3Scalar(q, 0.0))     
                            + min(max(q.x, max(q.y, q.z)), 0.0)
                            - cfg.s;
                    };
                    sdfFunctions[id] = opUnion(boxA, boxB, cfg.s * 0.5);
                    delete remaining[id];
                    progress = true;
                    break;                
                case 'octahedron':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);            
                        const pr = applyRotation(pc, cfg);    
                        const pb = applyBending(pr, cfg.bend);
                        const r = cfg.r;
                        const x = abs(pb.x);
                        const y = abs(pb.y);
                        const z = abs(pb.z);
                        const m = x + y + z - r;
                        // Permute (x, y, z) so that q contains the two smallest coordinates.
                        let qx, qy, qz;
                        if (3.0 * x < m) {
                            qx = x; qy = y; qz = z;
                        } else if (3.0 * y < m) {
                            qx = y; qy = z; qz = x;
                        } else if (3.0 * z < m) {
                            qx = z; qy = x; qz = y;
                        } else {
                            const sdf3D = m * 0.57735027;     // 1/sqrt(3)
                            return sdf3D - cfg.s;
                        }
                        const k = clamp(0.5 * (qz - qy + r), 0.0, r);
                        const dx = qx;
                        const dy = qy - r + k;
                        const dz = qz - k;
                        const sdf3D = sqrt(dx * dx + dy * dy + dz * dz);
                        return sdf3D - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;                
                case 'pyramid':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);            
                        const pr = applyRotation(pc, cfg);    
                        const pb = applyBending(pr, cfg.bend);
                        const r = cfg.r;
                        const x = abs(pb.x);
                        const y = abs(pb.y);
                        const z = abs(pb.z);
                        // Octahedron-SDF 
                        const m = x + y + z - r;
                        let qx, qy, qz;
                        if (3.0 * x < m) {
                            qx = x; qy = y; qz = z;
                        } else if (3.0 * y < m) {
                            qx = y; qy = z; qz = x;
                        } else if (3.0 * z < m) {
                            qx = z; qy = x; qz = y;
                        } else {
                            const sdfOct = m * 0.57735027;
                            const sdfHalf = -pb.y;    // y>=0
                            const sdf3D = max(sdfOct, sdfHalf);
                            return sdf3D - cfg.s;
                        }
                        const k = clamp(0.5 * (qz - qy + r), 0.0, r);
                        const dx = qx;
                        const dy = qy - r + k;
                        const dz = qz - k;
                        const sdfOct = sqrt(dx * dx + dy * dy + dz * dz);
                        const sdfHalf = -pb.y;
                        const sdf3D = max(sdfOct, sdfHalf);  // y>=0 → pyramid
                        return sdf3D - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'tetrahedron':
                    sdfFunctions[id] = function(p) {
                        cfg.c.y = -0.2 * cfg.r;  // midpoint compensation
                        const pc = sub3(p, cfg.c);
                        // ... additional rotation: tip pointing upwards ...
                            const pQuat = { w: 0.0, x: pc.x, y: pc.y, z: pc.z };
                            const qu =  { w: 0.8870, x: -0.3251, y: 0, z: 0.3251 };
                            const rotQ = quatConjugate(qu);
                            const invQ = qu;
                            const tmp = quatMul(rotQ, pQuat);
                            const res = quatMul(tmp, invQ);
                            let pr = { x: -res.x, y: -res.y, z: -res.z };
                        // ...........
                        pr = applyRotation(pr, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        let sd = Infinity;
                        const s = cfg.s;
                        const de = cfg.r / 3;
                        const planes = [
                            { normal: { x:  0.57735, y:  0.57735, z:  0.57735 }, d: de },
                            { normal: { x:  0.57735, y: -0.57735, z: -0.57735 }, d: de },
                            { normal: { x: -0.57735, y:  0.57735, z: -0.57735 }, d: de },
                            { normal: { x: -0.57735, y: -0.57735, z:  0.57735 }, d: de }
                        ];
                        for (let i = 0; i < planes.length; i++) {
                            const pl = planes[i];
                            const n = pl.normal;
                            // Compensated shift of the plane by empirical factor.
                            const d = pl.d - 0.75 * s;
                            const sdPlane = dot3(pb, n) - d;
                            if (i === 0) {
                                sd = sdPlane;
                            } else {
                                sd = -smoothMin(-sd, -sdPlane, s);
                            }
                        }
                        return sd - s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'polyhedron':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const s = cfg.s;
                        let sd = Infinity;
                        for (let i = 0; i < cfg.planes.length; i++) {
                            const pl = cfg.planes[i];
                            const n = normalize3(pl.normal);
                             // Compensated shift of the plane by empirical factor.
                            const d = pl.d - 0.75 * s;
                            const sdPlane = dot3(pb, n) - d;
                            if (i === 0) {
                                sd = sdPlane;
                            } else {
                                sd = -smoothMin(-sd, -sdPlane, s);
                            }
                        }
                        return sd - cfg.s;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                case 'paraboloid':
                    const parab = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const a  = cfg.a;
                        const a2 = a * a;
                        const rl = length2(xz(pb));
                        const r  = (rl > 0.0001) ? rl : 0.0001; // sonst eventuell Division durch 0
                        const y  = pb.y;
                        //  Intersection point x,y of parabola and normal line
                        const k  = -1 / (4 * a2 * r);
                        const rs = k + sqrt(k * k + y / a + 1 / (2 * a2));
                        const ys = -1 / (2 * a * r) * rs + y + 1 / (2 * a);
                        const dx = r - rs;
                        const dy = y - ys;
                        let d = sqrt(dx * dx + dy * dy); // Distance to the intersection point.
                        const hol = cfg.hollow;
                        if (!hol) {
                            if (y > a * r * r) d = -d;
                        }
                        return d;
                    };
                    {  //  in { ... } :   const plane is defined again below - localization
                        const plane = [
                            { normal: { x: 0, y: 1, z: 0 }, d: cfg.h }
                        ];
                        sdfFunctions[id] = opSection(parab, plane, cfg.s);
                    }
                    delete remaining[id];
                    progress = true;
                    break;                
                case 'powerparaboloid':
                    const rotbody_pp = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const a  = cfg.a;
                        const n  = cfg.n;
                        // calculations in the 2D r, y system 
                        const func = (r) => a * pow(r, n);
                        const mN = (r) => -1.0 / (a * n * pow(r, n - 1));  // normal increase
                        const rl = length2(xz(pb));
                        const r  = (rl > 0.0001) ? rl : 0.0001;
                        const yr = pb.y;
                        const m  = mN(r);
                        let r1 = 0.0;
                        let r2 = r + yr / (-m);     //  Intersection r-axis
                        // Signatures at the ends
                        let f1 = (yr + m * (r1 - r)) - func(r1);
                        let f2 = (yr + m * (r2 - r)) - func(r2);
                        while ((r2 - r1) > tsl / 100) {
                            const rm = 0.5 * (r1 + r2);
                            const ym = yr + m * (rm - r); //  Normal to rm
                            const fmid = ym - func(rm);
                            if (fmid === 0.0) break;
                            // replace right or left, depending on the sign
                            if (f1 * fmid < 0.0) {
                                r2 = rm; f2 = fmid;
                            } else {
                                r1 = rm; f1 = fmid;
                            }
                        }
                        const rs = 0.5 * (r1 + r2);
                        const dr = r - rs;
                        const dy = yr - func(rs);
                        let d = sqrt(dr * dr + dy * dy); // distance to the intersection point
                        const hol = cfg.hollow;
                        if (!hol) {
                            if (yr > func(rs)) d = -d;
                        }
                        return d;
                    };
                    const plane_pp = [
                        { normal: { x: 0, y: 1, z: 0 }, d: cfg.h }
                    ];
                    sdfFunctions[id] = opSection(rotbody_pp, plane_pp, cfg.s);
                    delete remaining[id];
                    progress = true;
                    break;                
                case 'cubic':
                    const rotbody_cu = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const a  = cfg.a;
                        const func = (r) => a * r * r * r / (1.0 + a * r * r);
                        const mN = (r) => {
                            const num = 3.0 * r * r + a * r * r * r * r;
                            const den = (1.0 + a * r * r);
                            let der = a * num / (den * den);
                            if (abs(der) < 1e-6) der = 1e-6;
                            return -1.0 / der;
                        };
                        const rl = length2(xz(pb));
                        const r  = (rl > 0.0001) ? rl : 0.0001;
                        const yr = pb.y;
                        const m  = mN(r);
                        let r1 = 0.0;
                        let r2 = r + yr / (-m);
                        let f1 = (yr + m * (r1 - r)) - func(r1);
                        let f2 = (yr + m * (r2 - r)) - func(r2);
                        while ((r2 - r1) > tsl / 100) {
                            const rm = 0.5 * (r1 + r2);
                            const ym = yr + m * (rm - r);
                            const fmid = ym - func(rm);
                            if (fmid === 0.0) break;
                            if (f1 * fmid < 0.0) {
                                r2 = rm; f2 = fmid;
                            } else {
                                r1 = rm; f1 = fmid;
                            }
                        }
                        const rs = 0.5 * (r1 + r2);
                        const dr = r - rs;
                        const dy = yr - func(rs);
                        let d = sqrt(dr * dr + dy * dy);
                        const hol = cfg.hollow;
                        if (!hol) {
                            if (yr > func(rs)) d = -d;
                        }
                        return d;
                    };
                    const plane_cu = [
                        { normal: { x: 0, y: 1, z: 0 }, d: cfg.h }
                    ];
                    sdfFunctions[id] = opSection(rotbody_cu, plane_cu, cfg.s);
                    delete remaining[id];
                    progress = true;
                    break;                    
                case 'cosparabol':
                    const rotbody_co = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const a = cfg.a;
                        const n = cfg.n;
                        const b = cfg.b;
                        const f = cfg.f;
                        const func = (r) => a * pow(r, n) + b * (1 - cos(f * r));
                        const mN = (r) => -1.0 / (a * n * pow(r, n - 1) + b * f * sin(f * r));
                        const rl = length2(xz(pb));
                        const r  = (rl > 0.0001) ? rl : 0.0001;
                        const yr = pb.y;
                        const m  = mN(r);
                        let r1 = 0.0;
                        let r2 = r + yr / (-m);
                        let f1 = (yr + m * (r1 - r)) - func(r1);
                        let f2 = (yr + m * (r2 - r)) - func(r2);
                        while ((r2 - r1) > tsl / 100) {
                            const rm = 0.5 * (r1 + r2);
                            const ym = yr + m * (rm - r);
                            const fmid = ym - func(rm);
                            if (fmid === 0.0) break;
                            if (f1 * fmid < 0.0) {
                                r2 = rm; f2 = fmid;
                            } else {
                                r1 = rm; f1 = fmid;
                            }
                        }
                        const rs = 0.5 * (r1 + r2);
                        const dr = r - rs;
                        const dy = yr - func(rs);
                        let d = sqrt(dr * dr + dy * dy);
                        const hol = cfg.hollow;
                        if (!hol) {
                            if (yr > func(rs)) d = -d;
                        }
                        return d;
                    };
                    const plane_co = [
                        { normal: { x: 0, y: 1, z: 0 }, d: cfg.h }
                    ];
                    sdfFunctions[id] = opSection(rotbody_co, plane_co, cfg.s);
                    delete remaining[id];
                    progress = true;
                    break;
                case 'hyperboloid':
                    const hbody = function(p) {
                        const h = cfg.h;
                        const a = cfg.a;
                        const r = cfg.r;
                        const s = cfg.s;
                        const hol = cfg.hollow;
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        let pb = applyBending(pr, cfg.bend);
                        const y = pb.y;
                        pb = { x: abs(pb.x), y: y, z: abs(pb.z) };
                        let rxz = length2(xz(pb));
                        // x = f(y) is the inverse function in each case => Designations: Envelope functions
                        rxz = max(1e-12, rxz);
                        // profile: inverse von y = a*sqrt(x^2-1)  =>  r(y) = sqrt(1 + (y/a)^2)
                        const profileR = sqrt(1.0 + (y / a) * (y / a));
                        const d0 = rxz - profileR - s - r;  // distance to the cover 
                        const dBot = -y;
                        const dTop = y - h;
                        const dPos = [ max(0.0, d0), max(0.0, dBot), max(0.0, dTop) ];
                        const outside = sqrt(dPos[0] * dPos[0] + dPos[1] * dPos[1] + dPos[2] * dPos[2]);
                        const inside  = min(max(d0, max(dBot, dTop)), 0.0);
                        const d = outside + inside;
                        if (hol) {
                            return abs(d);
                        } else {
                            return d;
                        }
                    };
                    const plane_hyp = [
                        { normal: { x: 0, y: 1, z: 0 }, d: cfg.h - cfg.s }
                    ];
                    const hTop = opSection(hbody, plane_hyp, cfg.s);
                    const hBtm = opMirrorXZ(hTop);
                    const hyper = opUnion(hTop, hBtm, 0.0);
                    const Cyl = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const rCyl = 1 + cfg.r;
                        const sdf3D = cylinderSDF(pb, rCyl, rCyl, cfg.h * 0.2);
                        return sdf3D;
                    };
                    sdfFunctions[id] = opSubtraction(hyper, Cyl, 0.001);
                    delete remaining[id];
                    progress = true;
                    break;                
                case 'prism':
                    switch (cfg.n) {
                        case 3:
                            sdfFunctions[id] = function(p) {
                                const pc      = sub3(p, cfg.c);
                                const pr      = applyRotation(pc, cfg);
                                const p_loc   = applyBending(pr, cfg.bend);
                                let p2      = xy(p_loc);
                                const k       = sqrt(3.0);
                                p2.x = abs(p2.x) - cfg.r;
                                p2.y = p2.y + cfg.r / k;
                                if (p2.x + k * p2.y > 0.0) {
                                    p2 = { x: (p2.x - k * p2.y) * 0.5, y: (-k * p2.x - p2.y) * 0.5 };
                                }
                                p2.x -= clamp(p2.x, -2.0 * cfg.r, 0.0);
                                const sdf2D   = -length2(p2) * sign(p2.y);
                                const d       = cfg.d / 2;
                                return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 4:
                            sdfFunctions[id] = function(p) {
                                const pc    = sub3(p, cfg.c);
                                const pr    = applyRotation(pc, cfg);
                                const p_loc = applyBending(pr, cfg.bend);
                                let p2    = xy(p_loc);
                                p2    = abs2(p2);
                                const d2    = sub2(p2, { x: cfg.r, y: cfg.r });
                                const dPos  = max2Scalar(d2, 0.0);
                                const sdf2D = length2(dPos) + min(max2(d2), 0.0);
                                const d     = cfg.d / 2;
                                return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 5:
                            sdfFunctions[id] = function(p) {
                                const pc      = sub3(p, cfg.c);
                                const pr      = applyRotation(pc, cfg);
                                const p_loc   = applyBending(pr, cfg.bend);
                                let p2      = xy(p_loc);
                                p2.x = abs(p2.x);
                                const k       = { x: 0.809016994, y: 0.587785252, z: 0.726542528 };
                                let dot1    = dot2({ x: -k.x, y: k.y }, p2);
                                const m1      = min(dot1, 0.0);
                                p2 = sub2(p2, mul2Scalar({ x: -k.x, y: k.y }, 2.0 * m1));
                                let dot2v    = dot2({ x: k.x, y: k.y }, p2);
                                const m2      = min(dot2v, 0.0);
                                p2 = sub2(p2, mul2Scalar({ x: k.x, y: k.y }, 2.0 * m2));
                                const r       = cfg.r;
                                const clamped = clamp(p2.x, -r * k.z, r * k.z);
                                p2 = { x: p2.x - clamped, y: p2.y - r };
                                const sdf2D   = length2(p2) * sign(p2.y);
                                const d       = cfg.d / 2;
                                return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 6:
                            sdfFunctions[id] = function(p) {
                                const pc = sub3(p, cfg.c);
                                const pr = applyRotation(pc, cfg);
                                let pb = applyBending(pr, cfg.bend);
                                pb = abs3(pb);
                                const k = { x: -0.8660254, y: 0.5, z: 0.57735 };
                                const dot = dot2({ x: k.x, y: k.y }, xy(pb));
                                const m   = min(dot, 0.0);
                                pb.x -= 2.0 * m * k.x;
                                pb.y -= 2.0 * m * k.y;
                                const clx = clamp(pb.x, -k.z * cfg.r, k.z * cfg.r);
                                const vxy = { x: pb.x - clx, y: pb.y - cfg.r };
                                const d0  = length2(vxy) * ((pb.y - cfg.r >= 0.0) ? 1.0 : -1.0);
                                const d1  = pb.z - cfg.d / 2;
                                const m0  = max(d0, d1);
                                const mv  = { x: max(d0, 0.0), y: max(d1, 0.0) };
                                return min(m0, 0.0) + length2(mv) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 8:
                            sdfFunctions[id] = function(p) {
                                const pc      = sub3(p, cfg.c);
                                const pr      = applyRotation(pc, cfg);
                                const p_loc   = applyBending(pr, cfg.bend);
                                let p2      = xy(p_loc);
                                p2      = abs2(p2);
                                const k       = { x: -0.9238795325, y: 0.3826834323, z: 0.4142135623 };
                                let dot1    = dot2({ x: k.x, y: k.y }, p2);
                                let m1      = min(dot1, 0.0);
                                p2 = sub2(p2, mul2Scalar({ x: k.x, y: k.y }, 2.0 * m1));
                                let dot2v    = dot2({ x: -k.x, y: k.y }, p2);
                                let m2      = min(dot2v, 0.0);
                                p2 = sub2(p2, mul2Scalar({ x: -k.x, y: k.y }, 2.0 * m2));
                                const r       = cfg.r;
                                const clamped = clamp(p2.x, -k.z * r, k.z * r);
                                p2 = { x: p2.x - clamped, y: p2.y - r };
                                const sdf2D   = length2(p2) * sign(p2.y);
                                const d       = cfg.d / 2;
                                return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                    } // switch prism
                    break;   
                case 'extrude':
                    switch (cfg.shape) {
                        case 'parallelogram':
                            sdfFunctions[id] = function(p) {
                                const pc     = sub3(p, cfg.c);
                                const pr     = applyRotation(pc, cfg);
                                const p_loc  = applyBending(pr, cfg.bend);
                                let p2       = xy(p_loc);
                                if (p2.y < 0.0) p2 = negate2(p2);
                                // convert: wi = half width, he = half height, sk = shear offset (skew) from angle
                                const wi     = cfg.whd.x * 0.5;
                                const he     = cfg.whd.y * 0.5;
                                const ang    = cfg['°'] * PI / 180.0;  // '°'  angle DEG
                                const sk     = he / tan(ang);
                                const e      = { x: sk, y: he };
                                let w        = sub2(p2, e); w.x -= clamp(w.x, -wi, wi);
                                const dw     = { x: dot2(w, w), y: -w.y };
                                const s      = p2.x * e.y - p2.y * e.x;
                                if (s < 0.0) p2 = negate2(p2);
                                let v        = sub2(p2, { x: wi, y: 0.0 });
                                const proj   = clamp(dot2(v, e) / dot2(e, e), -1.0, 1.0);
                                v            = sub2(v, mul2Scalar(e, proj));
                                const d2     = { x: dot2(v, v), y: wi * he - abs(s) };
                                const dn     = { x: min(dw.x, d2.x), y: min(dw.y, d2.y) };
                                const sdf2D  = sqrt(dn.x) * sign(-dn.y);
                                const d      = cfg.whd.z / 2;
                                return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 'vesica':
                            sdfFunctions[id] = function(p) {
                                const pc    = sub3(p, cfg.c);
                                const pr    = applyRotation(pc, cfg);
                                const p_loc = applyBending(pr, cfg.bend);
                                const p2    = abs2(xy(p_loc));
                                let w_cfg = cfg.whd.x;
                                let h_cfg = cfg.whd.y;
                                if (h_cfg > w_cfg) { [w_cfg, h_cfg] = [h_cfg, w_cfg]; }  // swap so that width is always ≥ height
                                const w = w_cfg;
                                const h = h_cfg;
                                const d0 = 0.5 * (w * w - h * h) / h;
                                let c;
                                if (w * p2.y < d0 * (p2.x - w)) {
                                    c = { x: 0.0, y: w, z: 0.0 };
                                } else {
                                    c = { x: -d0, y: 0.0, z: d0 + h };
                                }
                                const sub = sub2(p2, { x: c.y, y: c.x });
                                const sdf2D = length2(sub) - c.z;
                                const depth = cfg.whd.z / 2.0;
                                return opExtrusion(p_loc, sdf2D, depth) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 'cutdisk':
                            sdfFunctions[id] = function(p) {
                                const pc    = sub3(p, cfg.c);
                                const pr    = applyRotation(pc, cfg);
                                const p_loc = applyBending(pr, cfg.bend);
                                let p2      = xy(p_loc);
                                p2.x = abs(p2.x);
                                const r     = cfg.r;
                                let h       = cfg.h;
                               // input h: from r (semicircle) to 2*r full circle => h negative from 0 to - r 
                                h = r - h;
                                const w     = sqrt(r * r - h * h);
                                const s1    = (h - r) * p2.x * p2.x + w * w * (h + r - 2.0 * p2.y);
                                const s2    = h * p2.x - w * p2.y;
                                const sVal  = max(s1, s2);
                                let sdf2D;
                                if (sVal < 0.0) {
                                    sdf2D = length2(p2) - r;
                                } else if (p2.x < w) {
                                    sdf2D = h - p2.y;
                                } else {
                                    sdf2D = length2(sub2(p2, { x: w, y: h }));
                                }
                                const d  = cfg.d / 2.0;
                                return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 'unevencapsule':
                            sdfFunctions[id] = function(p) {
                                const pc    = sub3(p, cfg.c);
                                const pr    = applyRotation(pc, cfg);
                                const p_loc = applyBending(pr, cfg.bend);
                                let p2 = xy(p_loc);
                                p2.x = abs(p2.x);
                                const rb = cfg.rb;
                                const rt = cfg.rt;
                                const h_total = cfg.h;
                                const h = h_total - rb - rt;   // effective distance between the two circle centers
                                const b = (rb - rt) / h;
                                const a = sqrt(1.0 - b * b);
                                const k = dot2(p2, { x: -b, y: a });
                                let sdf2D;
                                if (k < 0.0) {
                                    sdf2D = length2(p2) - rb;
                                } else if (k > a * h) {
                                    sdf2D = length2(sub2(p2, { x: 0.0, y: h })) - rt;
                                } else {
                                    sdf2D = dot2(p2, { x: a, y: b }) - rb;
                                }
                                const d = cfg.d / 2.0;
                                return opExtrusion(p_loc, sdf2D, d) - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                    }  // switch extrude
                    break;
                
                case 'revolute':
                    switch (cfg.shape) {
                        case 'parallelogram':
                            sdfFunctions[id] = function(p) {
                                const pc    = sub3(p, cfg.c);
                                const pr    = applyRotation(pc, cfg);
                                const p_loc = applyBending(pr, cfg.bend);
                                // revolution around the y-axis with radius R, returns 2D point (x,y)
                                let p2   = opRevolution(p_loc, cfg.R);
                                if (p2.y < 0.0) {
                                    p2 = negate2(p2);
                                }
                                const wi  = cfg.whd.x * 0.5;
                                const he  = cfg.whd.y * 0.5;
                                const ang = cfg['°'] * PI / 180.0;
                                const sk  = he / tan(ang);
                                const e   = { x: sk, y: he };
                                let w    = sub2(p2, e);
                                w.x -= clamp(w.x, -wi, wi);
                                const dw  = { x: dot2(w, w), y: -w.y };
                                const s   = p2.x * e.y - p2.y * e.x;
                                if (s < 0.0) p2 = negate2(p2);
                                let v    = sub2(p2, { x: wi, y: 0.0 });
                                const proj = clamp(dot2(v, e) / dot2(e, e), -1.0, 1.0);
                                v        = sub2(v, mul2Scalar(e, proj));
                                const d2 = { x: dot2(v, v), y: wi * he - abs(s) };
                                const dn = { x: min(dw.x, d2.x), y: min(dw.y, d2.y) };
                                const sdf2D = sqrt(dn.x) * sign(-dn.y);
                                return sdf2D - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 'vesica':
                            sdfFunctions[id] = function(p) {
                                const pc    = sub3(p, cfg.c);
                                const pr    = applyRotation(pc, cfg);
                                const p_loc = applyBending(pr, cfg.bend);
                                let p2    = opRevolution(p_loc, cfg.R);
                                p2        = abs2(p2);
                                let w_cfg = cfg.whd.x;
                                let h_cfg = cfg.whd.y;
                                if (h_cfg > w_cfg) {[w_cfg, h_cfg] = [h_cfg, w_cfg];} // swap so that width is always ≥ height 
                                const w = w_cfg;
                                const h = h_cfg;
                                const d0    = 0.5 * (w * w - h * h) / h;
                                let c;
                                if (w * p2.y < d0 * (p2.x - w)) {
                                    c = { x: 0.0, y: w, z: 0.0 };
                                } else {
                                    c = { x: -d0, y: 0.0, z: d0 + h };
                                }
                                const sub = sub2(p2, { x: c.y, y: c.x });
                                const sdf2D = length2(sub) - c.z;
                                return sdf2D - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 'cutdisk':
                            sdfFunctions[id] = function(p) {
                                const pc = sub3(p, cfg.c);
                                const pr = applyRotation(pc, cfg);
                                const pb = applyBending(pr, cfg.bend ?? 0.0);
                                let p2 = opRevolution(pb, cfg.R);
                                p2.x = abs(p2.x);
                                const r = cfg.R;
                                let h = cfg.h;
                                h = r - h;   // input h: from r (semicircle) to 2*r full circle
                                const w = sqrt(r * r - h * h);
                                const s1 = (h - r) * (p2.x * p2.x) + w * w * (h + r - 2.0 * p2.y);
                                const s2 = h * p2.x - w * p2.y;
                                const sVal = max(s1, s2);
                                let sdf2D;
                                if (sVal < 0.0) {
                                    sdf2D = length2(p2) - r;
                                } else if (p2.x < w) {
                                    sdf2D = h - p2.y;
                                } else {
                                    sdf2D = length2(sub2(p2, { x: w, y: h }));
                                }
                                return sdf2D - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                        case 'unevencapsule': //  Triangulation errors with frequently very sharp indentations.
                            sdfFunctions[id] = function(p) {
                                const pc    = sub3(p, cfg.c);
                                const pr    = applyRotation(pc, cfg);
                                const p_loc = applyBending(pr, cfg.bend);
                                let p2 = opRevolution(p_loc, cfg.R);
                                p2 = abs2(p2);
                                const rb    = cfg.rb;
                                const rt    = cfg.rt;
                                const h_eff = cfg.h - rb - rt; // aus Gesamt-h die Mittelpunkts-Strecke errechnen
                                const b = (rb - rt) / h_eff;
                                const a = sqrt(1.0 - b * b);
                                const k = dot2(p2, { x: -b, y: a });
                                let dist2D;
                                if (k < 0.0) {
                                    dist2D = length2(p2) - rb;
                                } else if (k > a * h_eff) {
                                    dist2D = length2(sub2(p2, { x: 0.0, y: h_eff })) - rt;
                                } else {
                                    dist2D = dot2(p2, { x: a, y: b }) - rb;
                                }
                                return dist2D - cfg.s;
                            };
                            delete remaining[id];
                            progress = true;
                            break;
                    }  // switch revolute  
                    break;   
                case 'rotate':
                    const body = function(p) {
                        const h = cfg.h;
                        const a = cfg.a;
                        const f = cfg.f;
                        const n = cfg.n;
                        const s = cfg.s;
                        const r = cfg.r - s; // -s in compensation
                        const bev = cfg.bev;
                        const hol = cfg.hollow;
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                        const y = pb.y;
                        const pb2 = { x: abs(pb.x), y: y, z: abs(pb.z) };
                        let rxz = length2(xz(pb2));
                        // ---- Line Helper ----
                        // Line segment interpolator: linear interpolation between (h1,r1) and (h2,r2)
                        const linepart = function(hv, h1, r1, h2, r2) {
                            // defensive: if h1==h2 return r1 (or middle r)
                            if (abs(h2 - h1) < 1e-12) return 0.5 * (r1 + r2);
                            const t = (hv - h1) / (h2 - h1);
                            return r1 + (r2 - r1) * t;
                        };
                        const line = function(points, yv) {
                            const nPts = (points && points.length) ? points.length : 0;
                            if (nPts === 0) return 0.0;
                            const pts = points.slice(); // shallow copy
                            pts.sort(function(A, B) {
                                return A.h - B.h;
                            });
                            // If y <= first.h --> clamp to first.r (or extrapolate)
                            const h0 = pts[0].h;
                            const r0 = pts[0].r;
                            const hN = pts[nPts - 1].h;
                            const rN = pts[nPts - 1].r;
                            const extrapolate = (cfg.extrapolate !== undefined) ? cfg.extrapolate : true;
                            if (yv <= h0) {
                                if (extrapolate && nPts >= 2) {
                                    // linear extrapolation using first segment
                                    const h1 = pts[1].h, r1 = pts[1].r;
                                    return linepart(yv, h0, r0, h1, r1);
                                }
                                return r0;
                            }
                            if (yv >= hN) {
                                if (extrapolate && nPts >= 2) {
                                    // extrapolate using last segment
                                    const h1 = pts[nPts - 2].h, r1 = pts[nPts - 2].r;
                                    return linepart(yv, h1, r1, hN, rN);
                                }
                                return rN;
                            }
                             // find interval [i,i+1] with h_i <= y <= h_{i+1}
                            for (let i = 0; i < nPts - 1; i++) {
                                const hi = pts[i].h, hi1 = pts[i + 1].h;
                                if (yv >= hi && yv <= hi1) {
                                    const ri = pts[i].r, ri1 = pts[i + 1].r;
                                    return linepart(yv, hi, ri, hi1, ri1);
                                }
                            }
                            // fallback
                            return r0;
                        };
                        // ATTENTION: x = f(y) is the inverse function in each case => Designations Envelope function
                        // d0 = Distance to the cover
                        let d0 = 0.0;
                        switch (cfg.func) {
                            case 'bevel':
                                d0 = rxz - abs(y / bev + s) - r;
                                break;
                            case 'bevelcos':
                                d0 = rxz - abs(y / bev + s) - a * cos(f * y) - r;
                                break;
                            case 'sin':
                                d0 = rxz - a * sin(f * y) - r;
                                break;
                            case 'cos':
                                d0 = rxz - a * cos(f * y) - r;
                                break;
                            case 'pow':
                                {
                                    const basis = abs(y * a + s);
                                    const expo = 1 / n;
                                    d0 = rxz - pow(basis, expo) + s - r;
                                }
                                break;
                            case 'root':
                                d0 = rxz - a * pow(y, n) - r;
                                break;
                            case 'exp':
                                d0 = rxz - log((a * y + 1.0)) - s - r;
                                break;
                            case 'log':
                                d0 = rxz - exp(a * y) + 1.0 - s - r;
                                break;
                            case 'lines':
                                {
                                    const profileR = line(cfg.points, y);
                                    d0 = rxz - profileR - s - r;
                                }
                                break;
                            case 'linescos':
                                {
                                    const profileR = line(cfg.points, y);
                                    d0 = rxz - profileR - a * cos(f * y) - r;
                                }
                                break;
                            case 'curve':
                                {
                                    const profileR = spline(cfg.points, y);
                                    d0 = rxz - profileR - s - r;
                                }
                                break;
                            case 'hyperbola':
                                rxz = max(1e-12, rxz);
                                {
                                    const profileR = sqrt(1.0 + (y / a) * (y / a));
                                    d0 = rxz - profileR - r;
                                }
                                break;
                            default:
                                d0 = rxz - r;
                        }
                        
                        const dBot = -y;
                        const dTop = y - h;
                        
                        const dPos = [ max(0.0, d0), max(0.0, dBot), max(0.0, dTop) ];
                        const outside = sqrt(dPos[0] * dPos[0] + dPos[1] * dPos[1] + dPos[2] * dPos[2]);
                        const inside  = min(max(d0, max(dBot, dTop)), 0.0);
                        const dval = outside + inside;
                        if (hol) {
                            return abs(dval);
                        } else {
                            return dval;
                        }
                    };
                    const plane = [
                        { normal: { x: 0, y: 1, z: 0 }, d: cfg.h - cfg.s }
                    ];
                    sdfFunctions[id] = opSection(body, plane, cfg.s);
                    delete remaining[id];
                    progress = true;
                    break;
                    
                // -------------------------------------------------------------  
                
                // ++++ still in development ++++
                case 'nut':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const v = { x: pr.y, y: pr.x, z: pr.x / 2 + pr.y / 2 };
                        const w = mul3Scalar(max3(pr, v), 0.33);
                        const q = sub3(pr, w);
                        return length3(q) - 0.94 * cfg.r;
                    };
                    delete remaining[id];
                    progress = true;
                    break;    
                 // ++++ still in development ++++
                case 'sincos':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const v = { x: sin(pr.x), y: cos(3.14 * pr.y), z: sin(pr.z) };
                        const w = mul3Scalar(max3(pr, v), 0.4);
                        const q = sub3(pr, w);
                        return length3(q) - 0.66 * cfg.r;
                    };
                    delete remaining[id];
                    progress = true;
                    break;                       
                 // ++++ still in development ++++
                case 'test':
                    sdfFunctions[id] = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const v = { x: pr.x * 2, y: pr.x * 2, z: pr.x / 3 + pr.y / 3 };
                        const w = mul3Scalar(max3(pr, v), 0.25);
                        const q = sub3(pr, w);
                        return length3(q) - 0.75 * cfg.r;
                    };
                    delete remaining[id];
                    progress = true;
                    break;
                 // ++++ still in development ++++   
                case 'apple': {
                    const rapple = { x: 1.00, y: 0.9, z: 0.95 };
                    const rbtm  = { x: 0.19, y: 0.07, z: 0.17 };
                    const rtop  = { x: 0.12, y: 0.11, z: 0.11 };
                
                    const apple = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const sdf3D = ellipsoidSDF(pr, rapple);
                        return sdf3D;
                    };
                
                    const btmSDF = function(p) {
                        let cbtm = { x: 0, y: -cfg.c.y * 1.2 - rapple.y, z: 0 };
                        cbtm = applyInverseRotation(cbtm, cfg);
                        const pc = sub3(p, cbtm);
                        const pr = applyRotation(pc, cfg);
                        const sdf3D = ellipsoidSDF(pr, rbtm);
                        return sdf3D;
                    };
                
                    const topSDF = function(p) {
                        let ctop = { x: 0, y: cfg.c.y * 1.2 + rapple.y, z: 0 };
                        ctop = applyInverseRotation(ctop, cfg);
                        const pc = sub3(p, ctop);
                        const pr = applyRotation(pc, cfg);
                        const sdf3D = ellipsoidSDF(pr, rtop);
                        return sdf3D;
                    };
                
                    const sdfA = opSubtraction(apple, btmSDF, 0.12);
                    sdfFunctions[id] = opSubtraction(sdfA, topSDF, 0.12);
                    delete remaining[id];
                    progress = true;
                    break;
                }
                // ++++ still in development ++++
                case 'fruit': {
                    const rfruit = { x: 1.00, y: 1.6, z: 0.95 };
                    const rbtm   = { x: 0.19, y: 0.07, z: 0.17 };
                    const rtop   = { x: 0.12, y: 0.11, z: 0.11 };
                
                    const rgroove = {
                        radius: 0.5,
                        depth: 0.24,
                        x0: 0.3,
                        z0: 0.0
                    };
                
                    const fruit = function(p) {
                        const pc  = sub3(p, cfg.c);
                        const pr  = applyRotation(pc, cfg);
                        const pb  = applyBending(pr, cfg.bend);
                        return ellipsoidSDF(pb, rfruit);
                    };
                
                    const btmSDF = function(p) {
                        let cbtm = { x: 0, y: - (cfg.c.y * 1.2 + rfruit.y), z: 0 };
                        cbtm = applyInverseRotation(cbtm, cfg);
                        const pc = sub3(p, cbtm);
                        const pr = applyRotation(pc, cfg);
                        return ellipsoidSDF(pr, rbtm);
                    };
                
                    const topSDF = function(p) {
                        let ctop = { x: 0, y: (cfg.c.y * 1.2 + rfruit.y), z: 0 };
                        ctop = applyInverseRotation(ctop, cfg);
                        const pc = sub3(p, ctop);
                        const pr = applyRotation(pc, cfg);
                        return ellipsoidSDF(pr, rtop);
                    };
                
                    const grooveSDF = function(p) {
                        const pc = sub3(p, cfg.c);
                        const pr = applyRotation(pc, cfg);
                        const pb = applyBending(pr, cfg.bend);
                
                        const xOff = pb.x - rgroove.x0;
                        const zOff = pb.z - rgroove.z0;
                
                        const xn = xOff / rfruit.x;
                        const yn = pb.y / rfruit.y;
                        const zn = zOff / rfruit.z;
                
                        const rad = sqrt(xn * xn + zn * zn);
                
                        const radMax = sqrt(max(0.0, 1.0 - yn * yn));
                
                        const localDepth = rgroove.depth * radMax;
                
                        const rNorm = rgroove.radius / rfruit.x;
                
                        return rad - (rNorm - localDepth);
                    };
                
                    let sdfF = opSubtraction(fruit, btmSDF, 0.12);
                    sdfF = opSubtraction(sdfF, topSDF, 0.12);
                    sdfF = opSubtraction(sdfF, grooveSDF, 0.12);
                    sdfFunctions[id] = sdfF;
                    delete remaining[id];
                    progress = true;
                    break;
                }

                
                //  .... operations .............................................................
                case 'union':
                    if (cfg.op1 && cfg.op2 && sdfFunctions[cfg.op1] && sdfFunctions[cfg.op2]) {
                        sdfFunctions[id] = opUnion(sdfFunctions[cfg.op1], sdfFunctions[cfg.op2], cfg.s );
                        delete remaining[id];
                        progress = true;
                    }
                    // array of operands
                    if (cfg.op && Array.isArray(cfg.op) && cfg.op.length > 0 &&
                                cfg.op.every(opId => typeof sdfFunctions[opId] === 'function')) {
                        const funcs = cfg.op.map(opId => sdfFunctions[opId]); 
                        sdfFunctions[id] = opDynUnion(funcs, cfg.s );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                    
                case 'subtraction':
                    if (cfg.op1 && cfg.op2 && sdfFunctions[cfg.op1] && sdfFunctions[cfg.op2]) {
                        sdfFunctions[id] = opSubtraction(
                            sdfFunctions[cfg.op1],
                            sdfFunctions[cfg.op2],
                            cfg.s
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    if (cfg.op && Array.isArray(cfg.op) && cfg.op.length > 0 &&
                                cfg.op.every(opId => typeof sdfFunctions[opId] === 'function')) {
                        const funcs = cfg.op.map(opId => sdfFunctions[opId]); 
                        sdfFunctions[id] = opDynSubtraction(funcs, cfg.s );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
    
                case 'intersection':
                    if (cfg.op1 && cfg.op2 && sdfFunctions[cfg.op1] && sdfFunctions[cfg.op2]) {
                        sdfFunctions[id] = opIntersection(
                            sdfFunctions[cfg.op1],
                            sdfFunctions[cfg.op2],
                            cfg.s
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'blending':
                    if (cfg.op1 && cfg.op2 && sdfFunctions[cfg.op1] && sdfFunctions[cfg.op2]) {
                        sdfFunctions[id] = opBlending(
                            sdfFunctions[cfg.op1],
                            sdfFunctions[cfg.op2],
                            cfg.b,
                            cfg.s
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;

                case 'elongateX':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opElongateX(
                            sdfFunctions[cfg.op],
                            cfg.d
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'elongateY':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opElongateY(
                            sdfFunctions[cfg.op],
                            cfg.d
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'elongateZ':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opElongateZ(
                            sdfFunctions[cfg.op],
                            cfg.d
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'scale':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opScale(
                            sdfFunctions[cfg.op],
                            cfg.whd
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'displace':
                    if (cfg.op && cfg.func != null && cfg.d != null && cfg.f != null && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opDisplace(
                            sdfFunctions[cfg.op],
                            cfg.func,
                            cfg.d,
                            cfg.f
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;                    

                case 'repeat':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opLimitedRepetition(
                            sdfFunctions[cfg.op],
                            cfg.d,
                            cfg.nnn
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'section':
                    if (cfg.op && cfg.planes != null && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opSection(
                            sdfFunctions[cfg.op],
                            cfg.planes,
                            cfg.s
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                                   
                case 'rotation':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opRotation(sdfFunctions[cfg.op], cfg);
                        delete remaining[id];
                        progress = true;
                    }
                    break;
 
                case 'translation':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opTranslation(sdfFunctions[cfg.op], cfg);
                        delete remaining[id];
                        progress = true;
                    }
                    break;                    
                    
                case 'mirrorXY':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opMirrorXY(
                            sdfFunctions[cfg.op]
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'mirrorXZ':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opMirrorXZ(
                            sdfFunctions[cfg.op]
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'mirrorYZ':
                    if (cfg.op && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opMirrorYZ(
                            sdfFunctions[cfg.op]
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'mirrorPlane':
                    if (cfg.op && cfg.normal != null && cfg.d != null && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opMirrorPlane(
                            sdfFunctions[cfg.op],
                            cfg.normal,
                            cfg.d
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                case 'distort':
                    if (cfg.op && cfg.mode != null && cfg.dxyz != null && cfg.fxyz != null && sdfFunctions[cfg.op]) {
                        sdfFunctions[id] = opDistort(
                            sdfFunctions[cfg.op],
                            cfg.mode,
                            cfg.dxyz,
                            cfg.fxyz
                        );
                        delete remaining[id];
                        progress = true;
                    }
                    break;
                
                 default:
                        console.log  ('unknown type');
                   break;
            }
        }
    
        if (!progress) {
            const remainingKeys = Object.keys(remaining);
            if (remainingKeys.length > 0) {
                throw new Error('Circular or unknown SDF reference in: ' + remainingKeys.join(', '));
            }
        }
    };
    
    
     // .... Triangulation of the selected SDF ......................
     
    SDF = sdfFunctions[executeId];
    
    d = tsl;  // tsl: triangleSideLength - adaptation to these triangulation variant 
    dd = d * d;
    
    xp = startPoint[ 'x' ];
    yp = startPoint[ 'y' ];
    zp = startPoint[ 'z' ];
    
    xn = -direction[ 'x' ];
    yn = -direction[ 'y' ];
    zn = -direction[ 'z' ];
    
    unite = false;
    split = false;
    
    fronts.push([]);
    boundings.push([]);
    
    frontStock = 0;  // number of fronts still to be processed
    frontNo = 0;
    front = fronts[frontNo];
    
    pointToSDF( );
    getSDFnormal( );
    
    makeFirstTriangle( ); // first triangle creates a front
    
    while ( frontStock > 0 ) {
        
        if (  !unite && !split ) { // triangulation on the front
            
            smallAngles = [];
            
            for ( let i = 0; i < front.length; i ++ ) {
                
                if( front[ i ].ang === 0 ) calculateFrontAngle( i ); // is to be recalculated (angle was set to zero)
                
            }
        
            m = getMinimalAngleIndex( ); // front angle
            
            makeNewTriangles( m );
            
            if ( front.length > 9 && smallAngles.length === 0 ) {
                
                checkDistancesToUnite( m );
                checkDistancesToSplit( m );
                
            }
            
            if ( front.length === 3 ) {
                
                makeLastTriangle( ); // last triangle closes the front
                chooseNextFront( );  // if aviable
                
            }
            
        } else { // unite the active front to another front or split the active front
            
            if ( unite ) {
                
                uniteFront(  m, iUnite, fUnite, jUnite );
                trianglesAtUnionPoints( );
                unite = false;
                
            } else if ( split ) {
                
                splitFront( iSplit, jSplit );
                trianglesAtSplitPoints( );
                split = false;
                
            }
            
        }
        
    }
    
    g.setIndex( new THREE.BufferAttribute( new Uint32Array( g.indices ), 1 ) );
    g.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( g.positions ), 3 ) );
    g.setAttribute( 'normal', new THREE.BufferAttribute(  new Float32Array( g.normals), 3 ) );  

    //console.log( 'g.positions,  g.indices',   g.positions,  g.indices) /////////////////////////////////////////////
    document.getElementById('loading').style.visibility = 'hidden';
    dropZone.style.visibility = 'visible';
      
}


/* ----- FileReader as Promise ----- */
function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onerror = () => reject(new Error('Error reading the file.'));
    fr.onabort = () => reject(new Error('File reading aborted.'));
    fr.onload = () => resolve(fr.result);
    fr.readAsText(file, 'utf-8');
  });
}  

function downloadMeshGltf( ) {
    
    exporter.parse( SDFmesh, ( gltf ) => { out = JSON.stringify( gltf, null, 2 );
        saveString( out, 'mesh.gltf' );
        } 
    );
    
}

function saveString( text, filename ) {
    
    save( new Blob([text], { type: 'text/plain'  } ), filename );
    
}

function save( blob, filename ) {
    
    linkElem.href = URL.createObjectURL( blob );
    linkElem.download = filename;
     linkElem.click( );
    
     URL.revokeObjectURL( url ); // CHROME error 
    
}

function exportJavaScript( ) {
    
    const ffd = pow( 10, nDec.value );
    const round = ( x ) => ( floor( x * ffd ) / ffd ); // round for output
    
    downloadGltf.style.display = 'inline';
    
    showOutput( );
    exportLines.value = "";
    
    const pc =  geometry.attributes.position.array.length;
    const ic =  geometry.index.array.length;
    
    //const id = ID.value;
    
    let code;
    let out = "";
    
    // --- generate JavaScript code ---
    
    out = "/*... indexed BufferGeometry ... */ \n\n";
    
    out += "const geometry = new BufferGeometry();\n";
    
    out += "geometry.indices = new Uint32Array( [ ";
    
    for ( let i = 0; i < ic; i ++ ) {
        
        out += geometry.index.array[ i ];
        out += i < ic - 1  ? ", " : "";
        
        }
        
    out += " ] );\n";
    
    
    out += "geometry.positions = new Float32Array( [ ";
    
    for ( let p = 0; p < pc ; p ++ ) {
        
        out += round( geometry.attributes.position.array[ p ] );
        out += p < pc - 1  ? ", " : "";
        
    }
    
    out += " ] );\n";

    
    out += "geometry.normals = new Float32Array( [ ";
    
    for ( let p = 0; p < pc ; p ++ ) {
        
        out += round( geometry.attributes.normal.array[ p ] );
        out += p < pc - 1  ? ", " : "";
        
    }
    
    out += " ] );\n";
    
    
    out += "geometry.setIndex( new BufferAttribute( geometry.indices, 1 ) );\ngeometry.setAttribute( 'position', new BufferAttribute( geometry.positions, 3 ) );\ngeometry.setAttribute( 'normal', new BufferAttribute( geometry.normalss, 3 ) );\n ";
    
    
    exportLines.value = out;
    
    exportLines.select( );
    
    //if( toClpb.checked ) document.execCommand( "Copy" );
    
}

function showOutput( ) {
    
    output.style.display = 'inline';
        
}

function hideOutput( ) {
    
    exportLines.value = '';
    downloadGltf.style.display = 'none';
    output.style.display = "none";
    
}
 
// ......... triangulation functions  ..........................

function getSDFnormal( ) {
    const eps = 0.001;
     
    xn = SDF({ x: xp + eps, y: yp, z: zp }) - SDF({ x: xp - eps, y: yp, z: zp });
    yn = SDF({ x: xp, y: yp + eps, z: zp }) - SDF({ x: xp, y: yp - eps, z: zp });
    zn = SDF({ x: xp, y: yp, z: zp + eps }) - SDF({ x: xp, y: yp, z: zp - eps });
    
    len = length( xn, yn, zn );
    
    xn = xn / len;
    yn = yn / len;
    zn = zn / len;
    
}

function pointToSDF( ) {
    
    const xnn = -xn;
    const ynn = -yn;
    const znn = -zn;
    let dist = maxDistance;

    let pSDF = { x: xp, y: yp, z: zp };
    
    while( abs( dist ) > 0.01 ) {
            
        dist = SDF( pSDF );
        
        xp = xp + xnn * dist;
        yp = yp + ynn * dist;
        zp = zp + znn * dist;
        
        pSDF = { x: xp, y: yp, z: zp };
        
    }
    
}

function makeFirstTriangle(  ) {
      
    const xpStart = xp;  // memorize for second point
    const ypStart = yp;
    const zpStart = zp;
    
    // first point and normal
    g.positions[ posIdx     ] = xp;
    g.positions[ posIdx + 1 ] = yp;
    g.positions[ posIdx + 2 ] = zp;
                
    g.normals[ posIdx     ] = xn;
    g.normals[ posIdx + 1 ] = yn;
    g.normals[ posIdx + 2 ] = zn;
    
    front.push( { idx: posIdx / 3, ang: 0 } ); // first front point
    posIdx += 3;

    const k = ( abs( xn ) + 0.5 ) % 1; // fract
    
    // tangent1
    xt1 = -yn;
    yt1 =  xn - k * zn;
    zt1 = k * yn;
    
    len = length( xt1, yt1, zt1 ); 
    
    xt1 = xt1 / len;
    yt1 = yt1 / len;
    zt1 = zt1 / len;
     
    // tangent 2 ( cross )
    xt2 = yn * zt1 - zn * yt1;
    yt2 = zn * xt1 - xn * zt1;
    zt2 = xn * yt1 - yn * xt1;
    
    len = length( xt2, yt2, zt2 );
    
    xt2 = xt2 / len;
    yt2 = yt2 / len;
    zt2 = zt2 / len;
    
    xp = xpStart + xt1 * d;
    yp = ypStart + yt1 * d;
    zp = zpStart + zt1 * d;
    
    pointToSDF( );
    getSDFnormal( );
    
    g.positions[ posIdx     ] = xp;
    g.positions[ posIdx + 1 ] = yp;
    g.positions[ posIdx + 2 ] = zp;
    
    g.normals[ posIdx     ] = xn;
    g.normals[ posIdx + 1 ] = yn;
    g.normals[ posIdx + 2 ] = zn;
    
    front.push( { idx: posIdx / 3, ang: 0 } );
    posIdx += 3;
    
    xp = xpStart + xt2 * d;
    yp = ypStart + yt2 * d;
    zp = zpStart + zt2 * d;
    
    pointToSDF( ); 
    getSDFnormal( );
    
    g.positions[ posIdx     ] = xp;
    g.positions[ posIdx + 1 ] = yp;
    g.positions[ posIdx + 2 ] = zp;
    
    g.normals[ posIdx     ] = xn;
    g.normals[ posIdx + 1 ] = yn;
    g.normals[ posIdx + 2 ] = zn;
    
    front.push( { idx: posIdx / 3, ang: 0 } );
    posIdx += 3;
    
    g.indices[ indIdx     ] = 0;
    g.indices[ indIdx + 1 ] = 1;
    g.indices[ indIdx + 2 ] = 2;
    
    indIdx += 3;
    
    frontStock += 1;
    
}

function checkDistancesToUnite( m ) { // for new active front points
    
    let idxJ, xChk, yChk, zChk, ddUnite;
    let ddUniteMin = Infinity;
    unite = false;
    
    for ( let i = 0; i < insertFront.length; i ++ ) {
        
        getPoint( m + i );
        
        for ( let f = 0; f < fronts.length; f ++ ) {
            
            if ( f !== frontNo ) {
                
                xChk = ( xp > boundings[ f ][ 0 ] - d ) && ( xp < boundings[ f ][ 3 ] + d );
                yChk = ( yp > boundings[ f ][ 1 ] - d ) && ( yp < boundings[ f ][ 4 ] + d );
                zChk = ( zp > boundings[ f ][ 2 ] - d ) && ( zp < boundings[ f ][ 5 ] + d );
                
                if (  xChk || yChk || zChk ) {
                    
                    for ( let j = 0; j < fronts[ f ].length; j ++ ) {
                        
                        idxJ = fronts[ f ][ j ].idx * 3;
                        
                        // Hint: here (2) is exceptionally point in other front!
                        x2 = g.positions[ idxJ ]; 
                        y2 = g.positions[ idxJ + 1 ];
                        z2 = g.positions[ idxJ + 2 ];
                        
                        ddUnite = squareLength ( x2 - xp, y2 - yp, z2 - zp );
                        
                        if ( ddUnite < dd && ddUnite < ddUniteMin ) {
                            
                            ddUniteMin = ddUnite; 
                            iUnite = i;
                            jUnite = j;
                            fUnite = f;
                            unite = true;
                            
                        }
                        
                    }
                    
                }
                
            }
            
        }
        
    }
    
}	

function uniteFront( m, i, f, j ) {
    
    let tmp = [];
    
    tmp[ 0 ] = front.slice( 0, m + i + 1 );	
    tmp[ 1 ] = fronts[ f ].slice( j , fronts[ f ].length );
    tmp[ 2 ] = fronts[ f ].slice( 0 , j + 1 );
    tmp[ 3 ] = front.slice( m + i, front.length );
    
    unionIdxA = m + i;
    unionIdxB = m + i + 1 + fronts[ f ].length
    
    front = [];
    
    for ( let t = 0; t < 4; t ++ ) {
        
        for ( let k = 0; k < tmp[ t ].length ; k ++ ) {
            
            front.push( tmp[ t ][ k ] );
            
        }
        
    }
    
    fronts[ f ] = []; // empty united front
    
    frontStock -= 1; // front is eliminated
    
}

function trianglesAtUnionPoints( ) {
    
    nIns = 0; // count inserted points
    
    calculateFrontAngle( unionIdxA );
    calculateFrontAngle( unionIdxA + 1 );
    
    if ( front[ unionIdxA ].ang < front[ unionIdxA + 1 ].ang ) {
        
        makeNewTriangles( unionIdxA );
        nIns += n - 1;
        calculateFrontAngle( unionIdxA + 1 + nIns );
        makeNewTriangles( unionIdxA + 1 + nIns );
        nIns += n - 1;
        
    } else {
        
        makeNewTriangles( unionIdxA + 1 );
        nIns += n - 1;
        calculateFrontAngle( unionIdxA );
        makeNewTriangles( unionIdxA );
        nIns += n - 1;
    }
    
    calculateFrontAngle( unionIdxB + nIns );
    calculateFrontAngle( unionIdxB + 1 + nIns );
    
    if ( front[ unionIdxB + nIns ].ang < front[ unionIdxB + 1 + nIns ].ang ) {
        
        makeNewTriangles( unionIdxB + nIns );
        nIns += n - 1;
        calculateFrontAngle( unionIdxB + 1 + nIns );
        makeNewTriangles( unionIdxB + 1 + nIns );
        
    } else {
        
        makeNewTriangles( unionIdxB + 1 + nIns );
        calculateFrontAngle( unionIdxB + nIns );
        makeNewTriangles( unionIdxB + nIns );
        
    }
    
}

function checkDistancesToSplit( m ) { // for new active front points
    
    let mj, mjIdx, ddSplit;
    let ddSplitMin = Infinity;
    split = false;
    
    for ( let i = 0; i < front.length ; i ++ ) {
        
        for ( let j = 0; j < n; j ++ ) { // check n new points (insertFront)
            
            mj = m + j;
            
            // except new points themselves and neighbor points
            if ( abs( i - mj ) > 3 && abs( i - mj ) < front.length - 3 ) {
                
                mjIdx = front[ mj ].idx * 3;
                
                // Hint: here (1) is exceptionally new point in the front!
                x1 = g.positions[ mjIdx ]; 
                y1 = g.positions[ mjIdx + 1 ];
                z1 = g.positions[ mjIdx + 2 ];
                
                getPoint( i );
                
                ddSplit = squareLength ( x1 - xp, y1 - yp, z1 - zp );
                
                if ( ddSplit < dd && ddSplit < ddSplitMin ) {
                    
                    ddSplitMin = ddSplit;
                    iSplit = i;
                    jSplit = mj;
                    split = true; 
                    
                }
                
            }
            
        }
        
    }
    
}

function splitFront( iSplit, jSplit ) {
    
    let k;
    
    front[ iSplit ].ang = 0;
    front[ jSplit ].ang = 0;
    
    if ( iSplit > jSplit )  { // swap
        
        k = jSplit;
        jSplit = iSplit;
        iSplit = k;
        
    } 
    
    splitIdx = iSplit;	// lower index
    
    partFront = [];
    
    // to duplicate
    let frontI = front[ iSplit ];
    let frontJ = front[ jSplit ];
    
    partFront = front.splice( iSplit + 1, jSplit - iSplit - 1 );
    partFront.unshift( frontI );
    partFront.push( frontJ );
    
    fronts.push( partFront );
    
    partFrontBounds( );
    
    frontStock += 1; // new front created
    
}

function trianglesAtSplitPoints( ) {
    
    nIns = 0; // count inserted points
    
    let idx0 = splitIdx; // splitIdx is the lower index 
    let idx1 = splitIdx + 1;
    
    calculateFrontAngle( idx0 );
    calculateFrontAngle( idx1 );
    
    if ( front[ idx1 ].ang < front[ idx0 ].ang ){
        
        makeNewTriangles( idx1 );
        nIns += n - 1;
        calculateFrontAngle( idx0 );
        makeNewTriangles( idx0 );
        
    } else {
        
        makeNewTriangles( idx0 );
        nIns += n - 1;
        calculateFrontAngle( idx1 + nIns );
        makeNewTriangles( idx1 + nIns );
        
    }
    
}

function getMinimalAngleIndex( ) {
    
    let angle = Infinity;
    let m;
    
    for ( let i = 0; i < front.length; i ++ ) {
        
        if( front[ i ].ang < angle  ) {
            
            angle = front[ i ].ang ;
            m = i;
            
        }
        
    }
    
    return m;
    
}

function makeNewTriangles( m ) {
    
    insertFront = []; // new front points
    
    nT = floor( 3 * front[ m ].ang / PI ) + 1; // number of new triangles
    
    dAng = front[ m ].ang / nT;
    
    getPrevPoint( m );
    getPoint( m );
    getNextPoint( m );
    getNormal( m );
    
    calculateTangentsPoint( );
    
    d1 = length( x1 - xp, y1 - yp, z1 - zp );
    d2 = length( x2 - xp, y2 - yp, z2 - zp );
    
    d12 = length( x2 - x1, y2 - y1, z2 - z1 );
    
    // correction of dAng, nT in extreme cases
    
    if ( dAng < 0.8 && nT > 1 ) {
        
        nT --;
        dAng = front[ m ].ang / nT;
        
    }
    
    if ( dAng > 0.8 && nT === 1 && d12 > 1.25 * d ) {
        
        nT = 2; 
        dAng = front[ m ].ang / nT;
        
    }
    
    if ( d1 * d1 < 0.2 * d * d ||  d2 * d2 < 0.2 * d * d  ) {
        
        nT = 1;
        
    }
    
    n = nT - 1;  // n number of new points
    
    if ( n === 0 ) { // one triangle
        
        g.indices[ indIdx     ] = front[ m ].idx;
        g.indices[ indIdx + 1 ] = front[ prevFront( m ) ].idx; 
        g.indices[ indIdx + 2 ] = front[ nextFront( m ) ].idx;
        
        indIdx += 3;
        
        /////////////// DEBUG triangles ///////////////////////
        // stp ++
        ///////////////////////////////////////////////////////
        
        front[ prevFront( m ) ].ang = 0;
        front[ nextFront( m ) ].ang = 0;
        
        front.splice( m, 1 ); // delete point with index m from the front
        
    } else { // more then one triangle
        
        // point p is center of circle in tangent plane
        
        xc = xp;
        yc = yp;
        zc = zp;
        
        phi = dAng; // start angle in tangential system
        
        for ( let i = 0 ; i < n; i ++ ) {
            
            calculateSurfacePointAndNormal( );
            
            insertFront.push( { idx: posIdx / 3, ang: 0 } );

            posIdx += 3;
            
            phi += dAng;
            
        }
        
        g.indices[ indIdx     ] = front[ m ].idx;
        g.indices[ indIdx + 1 ] = front[ prevFront( m ) ].idx 
        g.indices[ indIdx + 2 ] = insertFront[ 0 ].idx;
        
        indIdx += 3;
        
        /////////////// DEBUG triangles ///////////////////////
        // stp ++
        ///////////////////////////////////////////////////////
        
        front[ prevFront( m ) ].ang = 0;
        
        for ( let i = 0; i < n - 1; i ++ ) {
            
            g.indices[ indIdx     ] = front[ m ].idx;
            g.indices[ indIdx + 1 ] = insertFront[ i ].idx;
            g.indices[ indIdx + 2 ] = insertFront[ i + 1 ].idx;
            
            indIdx += 3;
            
            /////////////// DEBUG triangles ///////////////////////
            // stp ++
            ///////////////////////////////////////////////////////
            
        }
        
        g.indices[ indIdx     ] = front[ m ].idx;
        g.indices[ indIdx + 1 ] = insertFront[ n - 1 ].idx;
        g.indices[ indIdx + 2 ] = front[ nextFront( m ) ].idx;
        
        front[ nextFront( m ) ].ang = 0;
        
        indIdx += 3;
        
        /////////////// DEBUG triangles ///////////////////////
        // stp ++
        ///////////////////////////////////////////////////////
        
        replaceFront( m, insertFront ); // replaces front[ m ] with new points
        
    }
    
}

function makeLastTriangle( ) {
    
    g.indices[ indIdx     ] = front[ 2 ].idx;
    g.indices[ indIdx + 1 ] = front[ 1 ].idx 
    g.indices[ indIdx + 2 ] = front[ 0 ].idx;
    
    indIdx += 3;
    
    /////////////// DEBUG triangles ///////////////////////
    // stp ++
    ///////////////////////////////////////////////////////
    
    front = [];
    
    fronts[ frontNo ] = [];
    
    frontStock -= 1; // close front
    
}

function chooseNextFront ( ) {
    
    if ( frontStock > 0 ) {
        
        for ( let i = 0; i < fronts.length; i ++ ) {
            
            if ( fronts[ i ].length > 0 ) {
                
                frontNo = i;
                break;
                
            }
            
        }
        
        front = fronts[ frontNo ];
        
        smallAngles = [];
        
        for ( let i = 0; i < front.length; i ++ ) {
            
            calculateFrontAngle( i ); // recalculate angles of next front
            
        }
        
    }
    
}

function calculateSurfacePointAndNormal( ) {
    
    xp = xc + cos( phi ) * d * xt1 + sin( phi ) * d * xt2;
    yp = yc + cos( phi ) * d * yt1 + sin( phi ) * d * yt2;
    zp = zc + cos( phi ) * d * zt1 + sin( phi ) * d * zt2; 
    
    getSDFnormal( );
    pointToSDF( );
    getSDFnormal( );

    g.positions[ posIdx     ] = xp;
    g.positions[ posIdx + 1 ] = yp;
    g.positions[ posIdx + 2 ] = zp;
    
    g.normals[ posIdx     ] = xn;
    g.normals[ posIdx + 1 ] = yn;
    g.normals[ posIdx + 2 ] = zn;
    
}

function atan2PI( x, y ) {
    
    let phi = atan2( y, x );
    
    if ( phi < 0 ) phi = phi + PI * 2;
    
    return phi;
    
}

function coordTangentialSystem( ) {	
    
    let det = determinant( xt1, yt1, zt1, xt2, yt2, zt2, xn, yn, zn );
    
    xs1 = determinant( x1 - xp, y1 - yp, z1 - zp, xt2, yt2, zt2, xn, yn, zn ) / det;
    ys1 = determinant( xt1, yt1, zt1, x1 - xp, y1 - yp, z1 - zp, xn, yn, zn ) / det;
    //zs1 = determinant( xt1, yt1, zt1, xt2, yt2, zt2, x1 - xp, y1 - yp, z1 - zp ) / det; // not needed
    
    xs2 = determinant( x2 - xp, y2 - yp, z2 - zp, xt2, yt2, zt2, xn, yn, zn ) / det;
    ys2 = determinant( xt1, yt1, zt1, x2 - xp, y2 - yp, z2 - zp, xn, yn, zn ) / det;
    //zs2 = determinant( xt1, yt1, zt1, xt2, yt2, zt2, x2 - xp, y2 - yp, z2 - zp ) / det; // not needed
    
}

function calculateFrontAngle( i ) {
    
    let ang1, ang2;
    
    getSystemAtPoint( i ); 
    getNextPoint( i ); // (2)  ==>>  x2, y2, z2  
    
    coordTangentialSystem( );
    
    ang1 = atan2PI( xs1, ys1 );
    ang2 = atan2PI( xs2, ys2 );
    
    if ( ang2 < ang1 )  ang2 += PI * 2;
    
    front[ i ].ang  = ang2 - ang1;
    
    if ( front[ i ].ang < 1.5 ) smallAngles.push( i );
    
}	

function partFrontBounds( ) {
    
    let x, y, z, idx, xmin, ymin, zmin, xmax, ymax, zmax;
    
    partBounds = [];
    
    xmin = ymin = zmin = Infinity;
    xmax = ymax = zmax = -Infinity;
    
    for( let i = 0; i < partFront.length; i ++ ) {
        
        idx = partFront[ i ].idx * 3;
        
        x = g.positions[ idx ]; 
        y = g.positions[ idx + 1 ];
        z = g.positions[ idx + 2 ];
        
        xmin = x < xmin ? x : xmin; 
        ymin = y < ymin ? y : ymin;
        zmin = z < zmin ? z : zmin;
        
        xmax = x > xmax ? x : xmax;
        ymax = y > ymax ? y : ymax;
        zmax = z > zmax ? z : zmax;
        
    }
    
    partBounds.push( xmin, ymin, zmin, xmax, ymax, zmax );
    boundings.push( partBounds );
    
}

function replaceFront( m, fNew ) {
    
    let rear = front.splice( m, front.length - m );
    
    for ( let i = 0; i < fNew.length; i ++ ) {
        
        front.push( fNew[ i ] ); // new front points
        
    }
    
    for ( let i = 1; i < rear.length; i ++ ) { // i = 1: without old front point m 
        
        front.push( rear[ i ] );
        
    }
    
}

function getNormal( i ){
    
    frontPosIdx = front[ i ].idx * 3;
    
    xn = g.normals[ frontPosIdx ]; 
    yn = g.normals[ frontPosIdx + 1 ];
    zn = g.normals[ frontPosIdx + 2 ];
    
}
            
function calculateTangentsPoint( ) {
    
    // cross
    
    xt2 = yn * ( z1 - zp ) - zn * ( y1 - yp );
    yt2 = zn * ( x1 - xp ) - xn * ( z1 - zp );
    zt2 = xn * ( y1 - yp ) - yn * ( x1 - xp );
    
    len = length( xt2, yt2, zt2 ); // to normalize
    
    xt2 = xt2 / len;
    yt2 = yt2 / len;
    zt2 = zt2 / len; 
    
    // cross
    xt1 = yt2 * zn - zt2 * yn;
    yt1 = zt2 * xn - xt2 * zn;
    zt1 = xt2 * yn - yt2 * xn;
    
}

function getSystemAtPoint( i ) {
    
    getPrevPoint( i );  // (1)  ==>>  x1, y1, z1 
    getPoint( i );      // xp, yp, zp
    
    getSDFnormal( );
    
    // first tangent
    const k = ( abs( xn ) + 0.5 ) % 1; // fract
    
    xt1 = -yn;
    yt1 = xn - k * zn;
    zt1 = k * yn;
    
    len = length( xt1, yt1, zt1 );
    
    xt1 = xt1 / len;
    yt1 = yt1 / len;
    zt1 = zt1 / len;
    
    // cross, second tangent 
    xt2 = yn * zt1 - zn * yt1;
    yt2 = zn * xt1 - xn * zt1;
    zt2 = xn * yt1 - yn * xt1;    
        
    len = length( xt2, yt2, zt2 );
    
    xt2 = xt2 / len;
    yt2 = yt2 / len;
    zt2 = zt2 / len;
    
}

function getPrevPoint( i ) {
    
    frontPosIdx = front[ prevFront( i ) ].idx * 3;
    
    x1 = g.positions[ frontPosIdx ];
    y1 = g.positions[ frontPosIdx + 1 ];
    z1 = g.positions[ frontPosIdx + 2 ];
    
}

function getPoint( i ) {
    
    frontPosIdx = front[ i ].idx * 3;
    
    xp = g.positions[ frontPosIdx ];
    yp = g.positions[ frontPosIdx + 1 ];
    zp = g.positions[ frontPosIdx + 2 ];
    
}

function getNextPoint( i ) {
    
    frontPosIdx = front[ nextFront( i ) ].idx * 3;
    
    x2 = g.positions[ frontPosIdx ];
    y2 = g.positions[ frontPosIdx + 1 ];
    z2 = g.positions[ frontPosIdx + 2 ];
    
}

</script>

</body>
</html>